# -*- mode:sh; tab-width:8; sh-basic-offset:2; indent-tabs-mode:t -*-
# vim: ts=8 sw=2 smarttab

#!/bin/bash
# file: rbd-recover-tool
##
# Author: Min Chen <minchen@ubuntukylin.com>
# Extended: Ralf Zerres <ralf.zerres@networkx.de>
#
# Copyright (C) 2015-2017 Ubuntu Kylin
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# rbd-recover-tool is an offline recover tool for rbd objects
# stored in replicated pools. It should be used, if all legal
# restauration efforts to recover your ceph-pool did not work out.
# rbd-recover-tool has a simple disater recovery policy, and is
# designed to just overcome urgent condition

version=1.01

#------------ admin node's action -------------

function scp_file()
{
  local func="scp_file"
  file=$1
  if [ "$1"x = ""x ];then
      echo "$func: missing parameter <file>"
      exit
  fi
  for host in `cat $osd_host`
  do
    {
      echo "$func: $host"
      scp $ssh_option $file $host:$job_path  1>/dev/null
    } &
  done
}

function scp_files()
{
  local func="scp_files"
  for host in `cat $osd_host`
  do
    {
      echo "$func: $host"
      scp $ssh_option $file1 $host:$job_path
      scp $ssh_option $file2 $host:$job_path
      scp $ssh_option $file3 $host:$job_path
      scp $ssh_option $file4 $host:$job_path
    } &
  done
  wait
  echo "$func: finish"
}

# admin node: cleanup the environment
function cleanup_env_admin()
{
  local func="cleanup_env_admin"
  if [ $verbose ]; then
      echo "$func: ..." 
  fi
  #local pwd_path=`pwd`
  #osd_host_mapping=$config_path/osd_host_mapping
  #if [ ! -s $osd_host_papping ]; then
  #  echo "$func: $config_path/osd_host_mapping does not exists or is empty"
  #  exit
  #fi
  if [ -e $images ]; then
    rm -rf $images
  fi
  if [ -e $rbd_metadata ]; then
    rm -rf $rbd_metadata
  fi
  if [ -e $osd_host ]; then
    rm -f $osd_host
  fi
  if [ -e $osd_host_mapping ]; then
    rm -f $osd_host_mapping
  fi
  if [ -e $osd_host_data ]; then
    rm -f $osd_host_data
  fi
}

# admin node process file: osd_host_path
function init_env_admin()
{
  local func="init_env_admin" 
  if [ ! -s $osd_host_path ]; then
    echo "$func: $osd_host_path does not exists"
    exit
  fi
  if [ ! -e $rbd_image ]; then
    mkdir -p $rbd_image
  fi
  if [ ! -e $images ]; then
    mkdir -p $images
  fi

  if [ ! -s $mon_host ]; then
    echo "$func: config/mon_host does not exists"
    exit
  fi
  if [ ! -e $mds_host ]; then
    echo "$func: config/mds_host does not exists"
    exit
  fi

  # only process, if osd_host_path has been updated recently
  if [ -s $osd_host ] && [ $osd_host -nt $osd_host_path ]; then
    return  
  fi  
  echo "$func: prepare client-side environment ..."
  # create file: osd_host and osd_host_mapping
  >$osd_host
  >$osd_host_mapping
  local lines=0
  local lineno=0

  # serialize osd-node hostname checking
  osd_host_path_sort $osd_host_path

  local lastnode=
  while read line
  do
    lineno=$(($lineno + 1))
    local node=`echo $line|awk '{print $1}'`
    if [ "$node"x = ""x ]; then
      echo "$func: osd_host_path : line $lineno: missing parameter <hostname>"
      rm -rf $osd_host $osd_host_mapping
      exit
    fi
    local data_path=`echo $line|awk '{print $2}'`
    if [ "$data_path"x = ""x ]; then
      echo "$func: osd_host_path : line $lineno: missing parameter <osd_data_path>"
      rm -rf $osd_host $osd_host_mapping
      exit
    fi

    lines=$(($lines + 1))
    # if there are several hostnames for the same node
    # we just need the output of `hostname`
    local hostname_alias=
    if [ "$node"  != "$lastnode" ]; then
      if [ $debug ]; then
	  echo "$func: osd-node $node -> verify hostname, set hostname_alias"
      fi
      hostname_alias=`ssh $ssh_option $node "hostname" 2>/dev/null </dev/null`
      if [ "$hostname_alias"x = ""x ]; then
        echo "$func: osd_host_path: line $lineno: $node: failed to get alias for remote hostname"
	echo "$func: osd_host_path: your osd-node can't be reached via ssh ... terminating"
	rm -rf $osd_host $osd_host_mapping
	exit
      fi
      echo "$node $hostname_alias" >>$osd_host_mapping
      echo $node >> $osd_host
      # check ceph env on remote osd
      check_ceph_env $node $data_path
      lastnode=$node
    fi
  done < $osd_host_data
  if [ $lines = 0 ]; then
    echo "$func: invalid client setup"
    echo "\tplease create valid configuration lines: <osd-node> <osd_data_path>"
    exit
  fi
}

function cleanup_env_nodes()
{
  local func="cleanup_env_nodes"
  local host=
  echo "$func: ..."

  if [ -r $osd_host ]; then
      trap 'echo $func failed; exit' INT HUP
      while IFS=$' \t\n' read -r host
      do
	# on each osd-node: cleanup the environment
	echo "[$host]: osd-node -> cleanup environment"
	cmd="rm -rf $job_path $single_node"
	if [ $verbose ]; then
	    echo "[$host]: ssh $ssh_option $host $cmd"
	fi
	ssh $ssh_option $host $cmd &
      done < $osd_host
  else
    if [ $verbose ]; then
	echo "$func: config file '$osd_host' already deleted!" 
    fi
  fi
  
}

function init_env_nodes()
{
  local func="init_env_nodes"
  local host=
  local lasthost=
  local data_path=
  echo "$func: ..."

  trap 'echo $func failed; exit' INT HUP
  # backgrounded ssh output need to be distinguished from calling shell (here: <&5)
  while IFS=$' \t\n' read -r host data_path <&5
  do
    # on each osd-node: setup the environment
    if [ "$host" != "$lasthost" ]; then
	lasthost=$host

	echo "[$host]: osd-node -> populate environment"
	cmd="mkdir -p $job_path"
	if [ $verbose ]; then
	    echo "[$host]: ssh $ssh_option $host $cmd"
	    echo "[$host]: scp $ssh_option $file1 $file2 $file3 $file4 $host:$job_path"
	fi
	ssh $ssh_option $host $cmd &&
	    scp $ssh_option $file1 $file2 $file3 $file4 $host:$job_path >/dev/null &
	wait
    fi
  done 5< $osd_host_data
  echo "$func: finished"
}

function scatter_node_jobs()
{
  local func="scatter_node_jobs"
  local host=
  local data_path=
  echo "$func: ..."

  if [ $verbose ]; then
      echo "$func: populate jobs and wait for end of their execution ..."
  fi

  while IFS=$' \t\n' read -r host data_path
  do
    {
      # ensure that regular ceph processes are inactive
      check_osd_process $host

      # on each osd-node: first flush the osd journals for given osd-path
      cmd="bash $job_path/osd_job flush_osd_journal $data_path;"
      ssh $ssh_option $host $cmd </dev/null
    } &
  done < $osd_host_data
  wait
  while IFS=$' \t\n' read -r host data_path
  do
    {
      # on each osd-node: extract Object-maps and PlacementGroup-maps for given osd-path
      cmd="bash $job_path/osd_job do_omap_list $data_path;"
      cmd="$cmd bash $job_path/osd_job do_pg_epoch $data_path;"
      cmd="$cmd bash $job_path/osd_job do_image_list $data_path;"  
      #if [ $debug ]; then
      #	echo "[$host]: ssh $ssh_option $host $cmd"
      #fi
      ssh $ssh_option $host $cmd </dev/null
    } &
  done < $osd_host_data
  wait

  echo "$func: finish"
}

function gather_node_infos()
{
  local func="gather_node_infos"
  echo "$func ..."
  >$pg_coll
  >$image_coll_v1
  >$image_coll_v2
  trap 'echo $func failed; exit' INT HUP
  while IFS=$' \t\n' read -r host data_path
  do
    {
      #host=`echo $line|awk '{print $1}'`
      #data_path=`echo $line|awk '{print $2}'`
      echo "$func: processing ceph-node $host"
      #check_osd_process $host

      #pg epoch
      cmd1="bash $job_path/osd_job cat_pg_epoch $data_path"
      ssh $ssh_option $host $cmd1 >> $pg_coll
      #image v1
      cmd2="bash $job_path/osd_job cat_image_v1 $data_path"
      ssh $ssh_option $host $cmd2 >> $image_coll_v1
      #image v2
      cmd3="bash $job_path/osd_job cat_image_v2 $data_path"
      ssh $ssh_option $host $cmd3 >> $image_coll_v2
    } &
  done < $osd_host_data
  wait
  echo "$func: finish"
}

function scatter_gather()
{
  local func="scatter_gather"
  if [ ! -s $osd_host ];then
      echo "$func: missing input parameter <osd_host>"
      exit
  fi
  if [ ! -s $mon_host ];then
      echo "$func: missing input parameter <mon_host>"
      exit
  fi
  scatter_node_jobs
  gather_node_infos
}


#------------- operations --------------

function init()
{
  init_env_admin
  init_env_nodes
}

function cleanup()
{
  cleanup_env_nodes
  cleanup_env_admin
}

function database()
{
  gen_database
  scatter_gather
}

function list()
{
  #init_env_nodes
  #gather_node_infos
  list_images
}

function lookup()
{
  #init_env_nodes
  # process rbd image-metadata: <pool-id> <rbd-name> <snap-name>
  lookup_image $1 $2 $3
}

function recover()
{
  #init_env_nodes
  # recover rbd object: <pool-id> <rbd-name> <snap-name> <dest-path>
  recover_image $1 $2 $3 $4
}

#------------- helper -------------

function get_path()
{
  local func="get_path"
  if [ $# -lt 1 ]; then
      return
  fi
  if [[ $1 =~ // ]]; then
      return # "/path//to" is invalid
  fi
  local parent=`dirname $1`
  local name=`basename $1`
  if [ "$parent"x = "/"x ]; then
      echo "$parent$name"
  else
    echo -n "$parent/$name"
  fi
}

function parse_mode_args () {
  local func="parse_mode_args"

  # check positional parameters for given mode
  case $mode in
    "lookup")
      pool_id=-1
      image_name=
      snap_name=
      if [[ $1 =~  ^([^@/]+)/([^@/]+)$ ]]; then
	  pool_id="${BASH_REMATCH[1]}"
	  image_name="${BASH_REMATCH[2]}"
      elif [[ $1 =~  ^([^@/]+)/([^@/]+)@([^@/]*)$ ]]; then
          pool_id="${BASH_REMATCH[1]}"
	  image_name="${BASH_REMATCH[2]}"
	  snap_name="${BASH_REMATCH[3]}"
      else
	if [ -z $1 ]; then 
	  echo "$func: given rbd-object is missing, use <pool_id>/<image_name>[@[<snap_name>]]"
	else
	  echo "$func: sytax error for $1, use <pool_id>/<image_name>[@[<snap_name>]]"
	fi  
	echo "$func: run mode <list> to get a list of recognized rbd-objects"
	exit
      fi
      ;;
    "recover")
      pool_id=-1
      image_name=
      snap_name=@
      image_dir=
      if [[ $1 =~  ^([^@/]+)/([^@/]+)$ ]]; then
	  pool_id="${BASH_REMATCH[1]}"
	  image_name="${BASH_REMATCH[2]}"
      elif [[ $1 =~  ^([^@/]+)/([^@/]+)@([^@/]*)$ ]]; then
	  pool_id="${BASH_REMATCH[1]}"
	  image_name="${BASH_REMATCH[2]}"
	  snap_name="${BASH_REMATCH[3]}"
	  if [ "$snap_name"x = ""x ]; then
              snap_name=@@
	  fi
      else
	if [ -z $1 ]; then 
	  echo "$func: given rbd-object is missing, use <pool_id>/<image_name>[@[<snap_name>]]"
	else
	  echo "$func: sytax error for $1, use <pool_id>/<image_name>[@[<snap_name>]]"
	fi  
	echo "$func: run mode <list> to get a list of recognized rbd-objects"
	exit
      fi
      if [ $# = 2 ];then
          image_dir=`get_path $2`
	  if [ "image_dir"x = ""x ]; then
              echo "$func: the given restore-path $2 is invalid!"
              exit
	  fi
      fi
      ;;
  esac
}

function parse_params () {
  local func="parse_params"
  ###
  # Evaluate given call parameters
  ###

  #test $# == 0 && usage
  while :
  do
    case $1 in
      --admin-config-path=*)
        config_path=${1#*=}
        shift
	if [ -z "$config_path" ]; then
	    echo "$func: --admin-config-path: no positional argument given."
	    exit 1
	else
          shift
	  if [ ! -d $config_path ]; then
	      echo "$func: given config-path $config_path does not exist!"
	      exit 1
	  else
	    update_config_file $my_dir/common_h rbd_config $config_path
	  fi
	fi
        ;;
      --admin-config-path)
        config_path=$2
	if [ -z "$config_path" ]; then
	    echo "$func: --admin-config-path: no positional argument given."
	    exit 1
	else
          shift 2
	  if [ ! -d $config_path ]; then
	      echo "$func: given config-path $config_path does not exist!"
	      exit 1
	  else
	    update_config_file $my_dir/common_h rbd_config $config_path
	  fi
	fi
        ;;
      --rbd-recover-home=*)
        rbd_recover_home=${1#*=}
        shift
	if [ ! -d $rbd_recover_home ]; then
	    echo "$func: will create $rbd_recover_home"
	    mkdir -p $rbd_recover_home
	fi
	update_config_file $my_dir/common_h rbd_recover_home $rbd_recover_home
        ;;
      --rbd-recover-home)
        rbd_recover_home=$2
	if [ -z "$rbd_recover_home" ]; then
	    echo "$func: --rbd_recover_home: no positional argument given."
	    exit 1
	else
          shift 2
	  if [ ! -d $rbd_recover_home ]; then
	      echo "$func: will create $rbd_recover_home"
	      mkdir -p $rbd_recover_home
	  fi
	  update_config_file $my_dir/common_h rbd_recover_home $rbd_recover_home
	fi
        ;;
      -d | --debug)
        debug=1
	verbose=1
        shift
        ;;
      -dry | --dryrun | --dry-run)
        dryrun=1
        shift
        ;;
      -m | --mode)
        mode=$2
	if [ -z "$mode" ]; then
	    echo "mode: no positional argument given."
	    echo "      please try $progname --usage"
	    exit 1
	else
          shift 2
	  parse_mode_args $1
	fi
        ;;
      cleanup|init|database|list|lookup|recover)
	mode=$1
	shift
	parse_mode_args $1
	;;
      --kvdb-type=*)
        kvdb_type=${1#*=}
        shift
	  if [ ! -z $kvdb_type ]; then
	    update_config_file $my_dir/common_h kvdb_type $kvdb_type
	  fi
        ;;
      --kvdb-type)
        kvdb_type=$2
	if [ -z "$kvdb_type" ]; then
	    echo "$func: --kvdb-type: no positional argument given."
	    exit 1
	else
          shift 2
	  if [ ! -z $kvdb_type ]; then
	    update_config_file $my_dir/common_h kvdb_type $kvdb_type
	  fi
	fi
        ;;
      --node-job-path=*)
        job_path=${1#*=}
        shift
        ;;
      --node-osd-path)
        single_node=$2
        shift 2
        ;;
      --mode=*)
        mode=${1#*=}
	if [ -z "$mode" ]; then
	    echo "mode: no positional argument given to operate on."
	    echo "      please try $progname --usage"
	    exit 1
	else
          shift
	  parse_mode_args "$1"
	fi
        ;;
      -v | --verbose)
        verbose=1
        shift
        ;;
      -V | --version)
        version
        shift
        ;;
      -h | --help | \-\? | --usage)
        #  Call usage() function.
        usage
        ;;
      --) # End of all options
        shift
        break
        ;;
      -*)
        echo "WARN: Unknown option (ignored): $1" >&2
        #shift
        exit 1
        ;;
      *)  # no more options. Stop while loop
        break
        ;;
    esac
  done

  # reread config after argument processing
  . $my_dir/common_h
  
  if [ $verbose ]; then
      echo "Admin RBD Config-Path:    $config_path"
      echo "Admin RBD Recover-Home:   $rbd_recover_home"
      echo "Admin RBD Metadata:       $rbd_metadata"
      echo "Admin RBD Image-Path:     $images"
      echo "Admin RBD Database-Path:  $database"
      #echo "Admin RBD Image-Dir:      $image_dir"
      echo "Node  OSD Job-Path:       $job_path"
      echo "Node  OSD Data-Path:      $single_node"
      echo "KeyValue DB-Type:         $kvdb_type"
      echo "SSH   Options:            $ssh_option"

      rbd_options="verbose=true";
      if [ $debug ]; then rbd_options="${rbd_options} debug=true"; fi

      echo "Options: ${rbd_options}"
      echo "Mode:    $mode"
  fi
}

function update_config_file()
{
  local func="update_config_file"

  local config_file=$1
  local t_key=$2
  local t_value=$3
  local t_config_file=/tmp/tmp_header_file.$$$$
  
  if [ "$1"x = ""x ];then
      echo "$func: missing parameter <config_file>"
      exit
  elif [ ! -w "$1" ];then
      echo "$func: Key $t_key can't be updated in config-file $1"
      exit
  fi
  cat $config_file | sed -e "s#$t_key=.*#$t_key=$t_value#" > $t_config_file
  if [ ! -z $t_config_file ]; then
      cp $t_config_file $config_file
      rm $t_config_file
  fi
}   
 

function usage () {
  echo "usage: $progname ..."
  echo
  echo "Comand-line interface to recover Ceph RBD images of a given replicated pool.
	Make sure to stop all ceph services an all involved ceph-nodes to
        asure noninvasive side effects."
  echo 
  echo "Positional argument:"
  echo "  [ -m | --mode ] <command>"
  echo "    cleanup
		    	remove environment on admin-node
			remove environment ond osd-nodes"
  echo "    init
			setup environment on admin-node
                        check availability of needed tools on osd-odes
                        check ceph structure on osd-nodes
                        populate environment to osd-nodes"
  echo "    database
			gather pg info, object info, image metadata,
		 	and epoch info from all osd nodes.
		    	this will cosume a long time, just be patient ...
			(especially when scale up to 1000+ osds)"
  echo "    list
		    	list all recognized rbd images in given replicated pools,
			run this, before executing mode lookup or recover"
  echo "    lookup  <pool_id>/<image_name>[@[<snap_name>]]
		    	show image metadata: image format, rbd id, size, order, snapseq
			In addtion, for image with snapshots, 
			this will list all snapshot infomations"
  echo "    recover <pool_id>/<image_name>[@[<snap_name>]] [</path/to/store/image>]
			all snapshots share one image head, to economize disk space
			so there is only one snapshot at any time,
			image is saved at </path/to/store/image>/pool_<pool_id>/image_name/image_name
			cat <path/to/store/image>/pool_<pool_id>/image_name/@CURRENT,
			will show snapid
		    	recover to raw image/nosnap/head: <image_name>
	            	rollback to image head:           <image_name>@
	            	rollback to image snap:           <image_name>@<snap_name>
			recover steps:
			1. recover image nosnap (only one time)
			2. rollback to image snap"
  echo "Optional arguments:"
  echo "  --admin-config-path	location of config definitions"
  echo "                        (default: $config_path)"
  echo "  --rbd-recover-home	home-path storing rbd-recover-tool data"
  echo "                        (default: $rbd_recover_home)"
  echo "  --kvdb-type   	database-type storing the key-value data"
  echo "                        (default: $kvdb_type)"
  echo "  --node-job-path	destination-path storing scripts to run on each osd-node"
  echo "                        (default: $job_path)"
  echo "  --node-data-path	destination-path storing metadata on given osd-node"
  echo "                        (default: $single_node)"
  echo "  -d | --debug		enable debug output"
  echo "  -v | --verbose	enable verbose output"
  echo "  --version     	show version number"
  exit 0
}

function version () {
  echo "$progname version: $version"
  exit 0
}

###
# Main
###

progname=`basename $0`

my_dir=$(dirname "$0")
config_path=$my_dir/config

# initialize with defaults
. $my_dir/database_h
# this inculdes
# +---> metadata_h
#   +-> epoch_h
#   +-> common_h


#scp files from admin node to osd node
file1=$my_dir/common_h
file2=$my_dir/metadata_h
file3=$my_dir/epoch_h
file4=$my_dir/osd_job

parse_params $@

case $mode in
  "init")
    # rebuild node variables
    rm -f $osd_host
    # setup admin environment
    init
    ;;
  "cleanup")
    # remove osd_host to refresh osd_host and osd_host_mapping
    cleanup
    ;;
  "database")
    # remove osd_host to refresh osd_host and osd_host_mapping
    #rm -f $osd_host
    database
    ;;
  "list")
    list
    ;;
  "lookup")
    lookup $pool_id $image_name $snap_name
    ;;
  "recover")
    #init_env
    recover $pool_id $image_name $snap_name $image_dir
    ;;
  *)  # no mode given, show usage
    usage
    ;;
esac

###
# EOF
###
