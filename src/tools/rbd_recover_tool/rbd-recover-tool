#!/bin/bash
# file: rbd-recover-tool
#
# Copyright (C) 2015 Ubuntu Kylin
#
# Author: Min Chen <minchen@ubuntukylin.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library Public License for more details.
#

# rbd-recover-tool is an offline recover tool for rbd image in replicated pool
# when ceph cluster is stopped.
# it is a simple disater recovery policy, just for urgent condition

my_dir=$(dirname "$0")

. $my_dir/common_h
. $my_dir/metadata_h
. $my_dir/epoch_h
. $my_dir/database_h

#scp files from admin node to osd node
file1=common_h
file2=metadata_h
file3=epoch_h
file4=osd_job

#------------ admin node's action -------------

function scp_file()
{
  local func="scp_file"
  file=$1
  if [ "$1"x = ""x ];then
    echo "$func: missing parameter <file>"
    exit
  fi
  for host in `cat $osd_host`
  do
  {
    echo "$func: $host"
    scp $ssh_option $file $host:$job_path  1>/dev/null
  } &
  done
}

function scp_files()
{
  local func="scp_files"
  for host in `cat $osd_host`
  do
  {
    echo "$func: $host"
    scp $ssh_option $file1 $host:$job_path
    scp $ssh_option $file2 $host:$job_path
    scp $ssh_option $file3 $host:$job_path
    scp $ssh_option $file4 $host:$job_path
  } &
  done
  wait
  echo "$func: finish"
}

function cleanup_env_nodes()
{
  local func="cleanup_env_nodes"
  local host=
  echo "$func: ..."

  trap 'echo $func failed; exit' INT HUP
  while IFS=$' \t\n' read -r host
  do
    # on each osd-node: cleanup the environment
    echo "[$host]: osd-node -> cleanup environment"
    cmd="rm -rf $job_path"
    if [ $verbose ]; then
	echo "[$host]: ssh $ssh_option $host $cmd"
    fi
    ssh $ssh_option $host $cmd &
  done < $osd_host
}

function init_env_nodes()
{
  local func="init_env_nodes"
  local host=
  local lasthost=
  local data_path=
  echo "$func: ..."

  trap 'echo $func failed; exit' INT HUP
  while IFS=$' \t\n' read -r host data_path <&5
  do
    #host=`echo $line|awk '{print $1}'`
    #data_path=`echo $line|awk '{print $2}'`

    # on each osd-node: setup the environment
    if [ "$host" != "$lasthost" ]; then
      lasthost=$host

      echo "[$host]: osd-node -> populate environment"
      cmd="mkdir -p $job_path"
      if [ $verbose ]; then
	echo "[$host]: ssh $ssh_option $host $cmd"
	echo "[$host]: scp $ssh_option $file1 $file2 $file3 $file4 $host:$job_path"
      fi
      ssh $ssh_option $host $cmd &&
      scp $ssh_option $file1 $file2 $file3 $file4 $host:$job_path >/dev/null &
      wait
    fi
  done 5< $osd_host_path
  echo "$func: finished"
}

function scatter_node_jobs()
{
  local func="scatter_node_jobs"
  local host=
  local data_path=
  echo "$func: ..."

  if [ $verbose ]; then
    echo "$func: populate jobs and wait for end of their execution ..."
  fi

  while IFS=$' \t\n' read -r host data_path
  do
  {
    #host=`echo $line|awk '{print $1}'`
    #data_path=`echo $line|awk '{print $2}'`

    # check_osd_process $host

    # on each osd-node: tasks to be run for any data-path
    cmd="bash $job_path/osd_job flush_osd_journal $data_path;"
    cmd="$cmd $job_path/osd_job do_omap_list $data_path;"
    cmd="$cmd bash $job_path/osd_job do_pg_epoch $data_path;"
    cmd="$cmd bash $job_path/osd_job do_image_list $data_path;"  
    ssh $ssh_option $host $cmd </dev/null      
    #if [ $debug ]; then
    #	echo "[$host]: ssh $ssh_option $host:$cmd"
    #fi
  } &
  done < $osd_host_path
  wait
  echo "$func: finish"
}

function gather_node_infos()
{
  local func="gather_node_infos"
  echo "$func ..."
  >$pg_coll
  >$image_coll_v1
  >$image_coll_v2
  trap 'echo $func failed; exit' INT HUP
  while IFS=$' \t\n' read -r host data_path
  do
  {
    #host=`echo $line|awk '{print $1}'`
    #data_path=`echo $line|awk '{print $2}'`
    echo "$func: processing ceph-node $host"
    #check_osd_process $host

    #pg epoch
    cmd1="bash $job_path/osd_job cat_pg_epoch $data_path"
    ssh $ssh_option $host $cmd1 >> $pg_coll
    #image v1
    cmd2="bash $job_path/osd_job cat_image_v1 $data_path"
    ssh $ssh_option $host $cmd2 >> $image_coll_v1
    #image v2
    cmd3="bash $job_path/osd_job cat_image_v2 $data_path"
    ssh $ssh_option $host $cmd3 >> $image_coll_v2
  } &
  done < $osd_host_path
  wait
  echo "$func: finish"
}

function scatter_gather()
{
  local func="scatter_gather"
  if [ ! -s $osd_host ];then
    echo "$func: missing input parameter <osd_host>"
    exit
  fi
  if [ ! -s $mon_host ];then
    echo "$func: missing input parameter <mon_host>"
    exit
  fi
  scatter_node_jobs
  gather_node_infos
}


#------------- operations --------------

function init()
{
    init_env_admin
    init_env_nodes
}

function cleanup()
{
    cleanup_env_nodes
    cleanup_env_admin
}

function database()
{
  scatter_gather
  gen_database
}

function list()
{
  init_env_nodes
  list_images
}

function lookup()
{
  init_env_nodes
  lookup_image $1 $2 $3
}

function recover()
{
  init_env_nodes
  recover_image $1 $2 $3 $4
}

#------------- helper -------------

function usage()
{
  local cmd_name="rbd-recover-tool"
  echo 
  echo "$cmd_name is used to recover rbd image of replicated pool, 
	when all ceph services are stopped"
  echo "Usage:"
  echo "$cmd_name database
		 	gather pg info, object info, image metadata, 
		 	and epoch info from all osd nodes,
		    	this will cosume a long time, just be patient, 
			especially when scale up to 1000+ osds"
  echo "$cmd_name list
		    	list all rbd images of all replicated pools, 
			before to lookup & recover"
  echo "$cmd_name lookup  <pool_id>/<image_name>[@[<snap_name>]]
		    	show image metadata: image format, rbd id, size, order, snapseq
			In addtion, for image with snapshots, 
			this will list all snapshot infomations"
  echo "$cmd_name recover <pool_id>/<image_name>[@[<snap_name>]] [</path/to/store/image>]
			all snapshots share one image head, to economize disk space
			so there is only one snapshot at any time,
			image is saved at </path/to/store/image>/pool_<pool_id>/image_name/image_name
			cat <path/to/store/image>/pool_<pool_id>/image_name/@CURRENT,
			will show snapid
		    	recover to raw image/nosnap/head: <image_name>
	            	rollback to image head:           <image_name>@
	            	rollback to image snap:           <image_name>@<snap_name>
			recover steps:
			1. recover image nosnap (only one time)
			2. rollback to image snap"
}

function get_path()
{
  local func="get_path"
  if [ $# -lt 1 ];then
    return
  fi
  if [[ $1 =~ // ]];then
    return # "/path//to" is invalid
  fi
  local parent=`dirname $1`
  local name=`basename $1`
  if [ "$parent"x = "/"x ];then
    echo "$parent$name"
  else
    echo -n "$parent/$name"
  fi
}

function admin_cmd()
{
  local func="admin_cmd"
  if [ $# -lt 1 ];then
    usage
    exit
  fi
  if [ "$1"x = "-h"x ] || [ "$1"x = "--help"x ];then
    usage
    exit
  fi
  
  if [ "$1"x = "init"x ];then
    if [ $# -gt 1 ];then
      usage
      exit
    fi
    # remove osd_host to refresh osd_host and osd_host_mapping
    rm -f $osd_host
    init_env
  elif [ "$1"x = "database"x ];then
    if [ $# -gt 1 ];then
      usage
      exit
    fi
    # remove osd_host to refresh osd_host and osd_host_mapping
    #rm -f $osd_host
    #init_env
    create_database
  elif [ "$1"x = "list"x ];then
    if [ $# -gt 1 ];then
      usage
      exit
    fi
    #init_env
    list
  elif [ "$1"x = "lookup"x ];then
    if [ $# -gt 2 ];then
      usage
      exit
    fi
    local pool_id=-1
    local image_name=
    local snap_name=
    if [[ $2 =~  ^([^@/]+)/([^@/]+)$ ]];then
      pool_id="${BASH_REMATCH[1]}"
      image_name="${BASH_REMATCH[2]}"
    elif [[ $2 =~  ^([^@/]+)/([^@/]+)@([^@/]*)$ ]];then
      pool_id="${BASH_REMATCH[1]}"
      image_name="${BASH_REMATCH[2]}"
      snap_name="${BASH_REMATCH[3]}"
    else
      echo "format: $2 is invalid, use <pool_id>/<image_name>[@[<snap_name>]]"
      exit
    fi
    #init_env
    lookup $pool_id $image_name $snap_name
    local pool_id=-1
    local image_name=
    local snap_name=
    if [[ $2 =~  ^([^@/]+)/([^@/]+)$ ]];then
      pool_id="${BASH_REMATCH[1]}"
      image_name="${BASH_REMATCH[2]}"
    elif [[ $2 =~  ^([^@/]+)/([^@/]+)@([^@/]*)$ ]];then
      pool_id="${BASH_REMATCH[1]}"
      image_name="${BASH_REMATCH[2]}"
      snap_name="${BASH_REMATCH[3]}"
    else
      echo "format: $2 is invalid, use <pool_id>/<image_name>[@[<snap_name>]]"
      exit
    fi
    #init_env
    lookup $pool_id $image_name $snap_name
  elif [ "$1"x = "recover"x ];then
    if [ $# -lt 2 ] || [ $# -gt 3 ];then
      usage
      exit
    fi
    local pool_id=-1
    local image_name=
    local snap_name=@
    local image_dir=
    if [[ $2 =~  ^([^@/]+)/([^@/]+)$ ]];then
      pool_id="${BASH_REMATCH[1]}"
      image_name="${BASH_REMATCH[2]}"
    elif [[ $2 =~  ^([^@/]+)/([^@/]+)@([^@/]*)$ ]];then
      pool_id="${BASH_REMATCH[1]}"
      image_name="${BASH_REMATCH[2]}"
      snap_name="${BASH_REMATCH[3]}"
      if [ "$snap_name"x = ""x ];then
        snap_name=@@
      fi
    else
      echo "format: $2 is invalid, use <pool_id>/<image_name>[@[<snap_name>]]"
      exit
    fi
    if [ $# = 3 ];then
      image_dir=`get_path $3`
      if [ "image_dir"x = ""x ];then
        echo "$3 invalid"
        exit
      fi
    fi
    #init_env
    recover $pool_id $image_name $snap_name $image_dir
  elif [ "$1"x = "scp_files"x ];then
    if [ $# -gt 1 ];then
      exit
    fi
    admin_parse_osd
    scp_files
  elif [ "$1"x = "scp_file"x ];then
    if [ $# -gt 2 ];then
      exit
    fi
    admin_parse_osd
    scp_file $2
  elif [ "$1"x = "cleanup"x ];then
    if [ $# -gt 1 ];then
      exit
    fi
    cleanup_env
  else
    echo "$func: $1: command not found"
  fi
}

admin_cmd $*
