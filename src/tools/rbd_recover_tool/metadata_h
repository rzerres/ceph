# -*- mode:sh; tab-width:8; sh-basic-offset:2; indent-tabs-mode:t -*-
# vim: ts=8 sw=2 smarttab

#!/bin/bash
# file: metadata_h
#
# Copyright (C) 2015-2017 Ubuntu Kylin
#
# Author:   Min Chen <minchen@ubuntukylin.com>
# Extended: Ralf Zerres <ralf.zerres@networkx.de>

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

my_dir=$(dirname "$0")

. $my_dir/epoch_h
. $my_dir/common_h

# put origin name in $image_name_in: for output
# put convert "_" name in $image_name: for grep image hobjects from database
image_name_in=
image_name=
function input_image()
{
  local func="input_image"
  if [ "$1"x = ""x ]; then
      echo "$func: no image name input"
      exit
  fi
  
  image_name_in=$1
  # "_" -> "\u"
  image_name=`convert_underline $image_name_in`
}

#======================================== distinguish v1 or v2 ===================================  
#image_list_v1=$single_node/$cluster-$id/image_list_v1
#image_list_v2=$single_node/$cluster-$id/image_list_v2
function get_image_list()
{
  find $osd_data/current/ -type f -regex '.*/rbd__.*' >$image_list_v1
  find $osd_data/current/ -type f -regex '.*/rbd.\uid.*' >$image_list_v2
}

function get_image_format_by_hobject()
{
  local func="get_image_format"
  if [ "$1"x = ""x ]; then
      exit
  fi
  local res1=`cat $image_list_v1|grep $1`  
  if [ "$res1"x != ""x ]; then
      echo 1
      exit
  fi  
  
  local res2=`cat $image_list_v2|grep  $1`
  if [ "$res2"x = ""x ]; then
      echo 2
      exit
  fi
}

#======================================== image format v1 ========================================  
# /*
#  * old-style rbd image 'foo' consists of objects
#  *   foo.rbd      - image metadata
#  *   rb.<idhi>.<idlo>.00000000
#  *   rb.<idhi>.<idlo>.00000001
#  *   ...          - data
#  */

# <image_name>.rbd inlude 3 parts:

# header + snap_count*snapshot + snap_count*snap_name
# 
# struct rbd_obj_header_ondisk {
# 40	char text[40];
# 24	char block_name[RBD_MAX_BLOCK_NAME_SIZE];
# 4	char signature[4];
# 8	char version[8];
# 	struct {
# 1		__u8 order;
# 1		__u8 crypt_type;
# 1		__u8 comp_type;
# 1		__u8 unused;
# 	} __attribute__((packed)) options;
# 8	__le64 image_size;//hexdump -C s=80 n=8
# 8	__le64 snap_seq;  //hexdump -C s=88 n=8
# 4	__le32 snap_count;//hexdump -C s=96 n=4
# 4	__le32 reserved;
# 8	__le64 snap_names_len; //hexdump -C s=104 n=8
# 	struct rbd_obj_snap_ondisk snaps[0];
# } __attribute__((packed));
#
# sizeof(rbd_obj_header_ondisk): 112
#
# struct rbd_obj_snap_ondisk {
# 8	__le64 id;             //hexdump -C s=112+i*16 n=8   , i=[0, snap_count)
# 8	__le64 image_size;     //hexdump -C s=112+i*16+8 n=8, i=[0, snap_count)
# } __attribute__((packed));
# sizeof(rbd_obj_snap_ondisk): 16
#
# get snap_names form <image_name>.rbd
# hexdump -e '10/1 "%_c"' -s $((112 + $snap_count*16)) -n $snap_names_len <image_name>.rbd
# then split snap_names into array

function get_image_metadata_v1()
{
  local func="get_image_metadata_v1"
  if [ "$1"x = ""x ]; then
      echo "$func: no image head object input"
      exit
  fi
  local snap_name=
  if [ "$2"x != ""x ]; then
      snap_name=$2 
  fi
  
  if [ ! -e $1 ]; then
      echo "$func: $1 not exists"
      exit
  fi
  local hobject_path=$1  
  d_hobject_path=`dump_backslash $1`
  local image_format=`get_image_format_by_hobject $d_hobject_path`
  if [ $image_format != 1 ]; then
      echo "$func: image_format must be 1"
      exit
  fi
  
  if [ ! -e $hobject_path ]; then
      echo "$func: $hobject_path not exists"
      exit
  fi

  # decode rbd_obj_header_ondisk of <image_name>.rbd
  local block_name=`hexdump -e '10/1 "%c"' -s 40 -n 24 $hobject_path`
  local order=`hexdump -e '10/4 "%u"' -s 76 -n 1 $hobject_path`
  local image_size=`hexdump -C -s 80 -n 8 $hobject_path|head -n 1|awk '{for (i=9; i>1; i--) {printf $i}}'`
  image_size=$((16#$image_size))
  local snap_seq=`hexdump -C -s 88 -n 8 $hobject_path|head -n 1|
	awk '{num=""; for(i=9; i>1; i--){ num=num""$i;} print strtonum("0x"num);}'`
  local snap_count=`hexdump -C -s 96 -n 4 $hobject_path|head -n 1|
	awk '{num=""; for(i=5; i>1; i--){ num=num""$i;} print strtonum("0x"num);}'` 
  local snap_names_len=`hexdump -C -s 104 -n 8 $hobject_path|head -n 1|
	awk '{num=""; for(i=9; i>1; i--){ num=num""$i;} print strtonum("0x"num);}'` 

  echo -e "block_name:\t$block_name"
  echo -e "order:\t\t$order"
  echo -e "image_size:\t$image_size"
  echo -e "snap_seq:\t$snap_seq"

  # decode N rbd_obj_snap_ondisk of <image_name>.rbd
  declare -a snap_ids
  declare -a snap_names
  declare -a snap_image_sizes
  local size_header=112 #sizeof(rbd_obj_header_ondisk)
  local size_snap=16 #sizeof(rbd_obj_snap_ondisk)
  local offset=0
  local id_off=0
  local size_off=0
  for ((i=0; i<$snap_count; i++))
  do
    offset=$(($size_header + $i * $size_snap)) 
    id_off=$offset 
    size_off=$(($offset + 8))
    snap_ids[$i]=`hexdump -C -s $id_off -n 8 $hobject_path|head -n 1|
	awk '{num=""; for(i=9; i>1; i--){num=num""$i;} print strtonum("0x"num);}'`
    snap_image_sizes[$i]=`hexdump -C -s $size_off -n 8 $hobject_path|head -n 1|
	awk '{num=""; for(i=9; i>1; i--){num=num""$i;} print strtonum("0x"num);}'`
  done
  offset=$(($size_header + $snap_count * $size_snap))
  snap_names=(`hexdump -e '10/1 "%_c"' -s $offset -n $snap_names_len $hobject_path|
  	awk -F "\\\\\\\\\\\\\\\\0" '{for(i=1; i<=NF; i++) {print $i" "} }'`); 

  echo -e "\t\tID\tNAME\t\tSIZE"
  for ((i=0; i<$snap_count; i++))
  do
    if [ "$snap_name"x = ""x ]; then
	echo -n -e "snapshot:\t"
	echo -e "${snap_ids[$i]}\t${snap_names[$i]}\t\t${snap_image_sizes[$i]}"
	continue
    fi
    if [ "$snap_name"x = "${snap_names[$i]}"x ]; then 
	echo -n -e "snapshot:\t"
	echo -e "${snap_ids[$i]}\t${snap_names[$i]}\t\t${snap_image_sizes[$i]}"
	return
    fi
  done
}

#======================================== end image format v1 ========================================  

#======================================== image format v2 ======================================== 

# /* New-style rbd image 'foo' consists of objects
#  *   rbd_id.foo              - id of image
#  *   rbd_header.<id>         - image metadata
#  *   rbd_object_map.<id>     - optional image object map
#  *   rbd_data.<id>.00000000
#  *   rbd_data.<id>.00000001
#  *   ...                     - data
#  */

# key/value: ceph-kvstore-tool kvdb-type /storepath get _USER_0000000000017426_USER_ (object_prefix|order|size|snap_seq)

# decode image id from image_id_hobject 
function get_image_id()
{
  local func="get_image_id"
  if [ "$1"x = ""x ]; then
      exit;
  fi
  local image_id_hobject=$1 #from admin node's database

  if [ ! -e $image_id_hobject ]; then
      echo "$func: given rados object id <$image_id_hobject> does not exist"
      exit;
  fi
  
  # get len of string (offset 0, 4 fields)  
  #local n=`hexdump -e '10/4 "%u"' -s 0 -n 4 $image_id_hobject`
  #hexdump -e '10/1 "%c"' -s 4 -n $n $image_id_hobject
  local lenhex=`xxd -seek 0 -len 1 -p $image_id_hobject`
  local len=$((16#$lenhex))
  xxd -seek 4 -len $len -p $image_id_hobject | xxd -p -r
}

#find image_id omap entry in omaplist
map_header_prefix=
map_header_key=
function get_map_header()
{
  local func="get_map_header"
  local image_id=$1
  if [ "$image_id"x = ""x ]; then
      echo "$func: ceph-kvstore-tool missing parameter <image_id>"
      exit;
  fi
  map_header_prefix=`get_map_header_prefix`
  local keyword="header%e"$image_id
  map_header_key=`get_map_header_key $keyword`
  if [ "$map_header_key"x = ""x ]; then
      echo "$func: map_header_key is NULL (not in omaplist)"
      exit
  fi
  if [ $debug ]; then
      echo "$func: map_header_key: $map_header_key"
  fi
}

#get meta header seq from map_header
meta_header_seq=
function get_meta_header_seq() 
{
  local func="get_meta_header_seq"
  if [ "$1"x == ""x ]; then
      echo "$func: ceph-kvstore-tool missing parameter <prefix>"
      exit;
  elif [ "$2"x == ""x ]; then
      echo "$func: ceph-kvstore-tool missing parameter <key>"
      exit;
  fi

  local prefix=$1;
  local key=$2;
  meta_header_seq=`get_header_seq $prefix $key`
  if [ $debug ]; then
      echo "$func: meta_header_seq: $meta_header_seq"
  fi
}

function get_image_metadata_v2()
{
  # ~ceph/ceph/tree/master/src/include/rbd/librbd.h
  # typedef struct {
  # uint64_t size;
  # uint64_t obj_size;
  # uint64_t num_objs;
  # int      order;
  # char     block_name_prefix[RBD_MAX_BLOCK_NAME_SIZE]; /* deprecated */
  # int64_t  parent_pool;			         /* deprecated */
  # char     parent_name[RBD_MAX_IMAGE_NAME_SIZE];       /* deprecated */
  #} rbd_image_info_t;

  # /* image options */
  # enum {
  #  RBD_IMAGE_OPTION_FORMAT = 0,
  #  RBD_IMAGE_OPTION_FEATURES = 1,
  #  RBD_IMAGE_OPTION_ORDER = 2,
  #  RBD_IMAGE_OPTION_STRIPE_UNIT = 3,
  #  RBD_IMAGE_OPTION_STRIPE_COUNT = 4,
  #  RBD_IMAGE_OPTION_JOURNAL_ORDER = 5,
  #  RBD_IMAGE_OPTION_JOURNAL_SPLAY_WIDTH = 6,
  #  RBD_IMAGE_OPTION_JOURNAL_POOL = 7,
  #  RBD_IMAGE_OPTION_FEATURES_SET = 8,
  #  RBD_IMAGE_OPTION_FEATURES_CLEAR = 9,
  #  RBD_IMAGE_OPTION_DATA_POOL = 10
  #};

  # CEPH_RBD_API int rbd_image_options_is_set(rbd_image_options_t opts,
  #                                           int optname, bool* is_set);  

  local func="get_image_metadata_v2"
  if [ "$1"x = ""x ]; then
      echo "$func: ceph-kvstore-tool missing parameter <meta_header_seq>"
      exit;
  fi
  # aline to 16 digets
  local meta_header_seq=`printf "%016d" $1`
  if [ $debug ]; then
      echo "$func: meta_header_seq = $meta_header_seq"
  fi
  local ghobject_key="_USER_"$meta_header_seq"_USER_"
  if [ $debug ]; then
      echo "$func: ghobject_key = $ghobject_key"
  fi

  object_prefix=$(get_header_kv $ghobject_key object_prefix string 4 20)
  order=$(get_header_kv $ghobject_key order int 0 1)
  image_size=$(get_header_kv $ghobject_key size int 4)
  snap_seq=$(get_header_kv $ghobject_key snap_seq int 0 )
  
  echo -e "object_prefix:\t$object_prefix"
  echo -e "order (2^x):\t$order"
  echo -e "object-size:\t$((2**$order/1024)) KBytes"
  echo -e "image_size:\t$image_size Bytes ($(($image_size/1024/1024)) GBytes)"
  echo -e "image_objects:\t$(($image_size/$((2**$order/1024))))"
  echo -e "snap_seq:\t$snap_seq"

  # list features
  list_features_v2 $1
  
  # ??? TODO: how about parent / overlap / protection?
  # // information about our parent image, if any
  # struct cls_rbd_parent {
  #   int64_t pool;        ///< parent pool id
  #   string id;           ///< parent image id
  #   snapid_t snapid;     ///< parent snapid we refer to
  #   uint64_t overlap;    ///< portion of this image mapped onto parent (bytes)
  #
  #   /// true if our parent pointer information is defined
  #   bool exists() const {
  #     return snapid != CEPH_NOSNAP && pool >= 0 && id.length() > 0 && overlap > 0;
  #   }
    
  # https://github.com/ceph/ceph/blob/master/src/cls/rbd/cls_rbd.h#L113
  # list_parent_v2 $1

  # list snapshot
  list_snapshots_v2 $1 $2
}

function list_features_v2()
{
  local func="list_features_v2"
  if [ "$1"x = ""x ]; then
      echo "$func: ceph-kvstore-tool missing parameter <meta_header_seq>"
      exit
  fi
  # Source definitions: /src/include/rbd/features.h
  #define RBD_FEATURE_LAYERING             (1ULL<<0)
  #define RBD_FEATURE_STRIPINGV2           (1ULL<<1)
  #define RBD_FEATURE_EXCLUSIVE_LOCK       (1ULL<<2)
  #define RBD_FEATURE_OBJECT_MAP           (1ULL<<3)
  #define RBD_FEATURE_FAST_DIFF            (1ULL<<4)
  #define RBD_FEATURE_DEEP_FLATTEN         (1ULL<<5)
  #define RBD_FEATURE_JOURNALING           (1ULL<<6)
  #define RBD_FEATURE_DATA_POOL            (1ULL<<7)
  
  #define RBD_FEATURE_NAME_LAYERING        "layering"
  #define RBD_FEATURE_NAME_STRIPINGV2      "striping"
  #define RBD_FEATURE_NAME_EXCLUSIVE_LOCK  "exclusive-lock"
  #define RBD_FEATURE_NAME_OBJECT_MAP      "object-map"
  #define RBD_FEATURE_NAME_FAST_DIFF       "fast-diff"
  #define RBD_FEATURE_NAME_DEEP_FLATTEN    "deep-flatten"
  #define RBD_FEATURE_NAME_JOURNALING      "journaling"
  #define RBD_FEATURE_NAME_DATA_POOL       "data-pool"

  # sum   255     all features set
  # sum   125     layering,exclusive-lock,object-map,fast-diff,deep-flatten,journaling
  # sum    61     layering,exclusive-lock,object-map,fast-diff,deep-flatten

  if [ $verbose ]; then
      echo "$func: get feature-mask ..."
  fi

  local rbd_feature_name_layering="layering"
  local rbd_feature_name_striping="striping"
  local rbd_feature_name_exclusive_lock="exclusive-lock"
  local rbd_feature_name_object_map="object-map"
  local rbd_feature_name_fast_diff="fast-diff"
  local rbd_feature_name_deep_flatten="deep-flatten"
  local rbd_feature_name_journaling="journaling"
  local rbd_feature_name_data_pool="data-pool"

  # bash has no multidemensional arrays,
  # we rely on a assosiative declaration
  declare -a rbd_feature_name
  rbd_feature_name=(
    $rbd_feature_name_layering
    $rbd_feature_name_striping
    $rbd_feature_name_exclusive_lock
    $rbd_feature_name_object_map
    $rbd_feature_name_fast_diff
    $rbd_feature_name_deep_flatten
    $rbd_feature_name_journaling
    $rbd_feature_name_data_pool
  )

  local features_max=${#rbd_feature_name[@]}
  local feature_list
  local features_active=0

  declare -a rbd_feature_value
  eval "rbd_feature_value=( $(for ((i=0; i<$features_max; i++)) do echo 0; done) )"

  if [ $debug ]; then
      echo "$func: get_header_kv $prefix features init 0 1)"
  fi
  local feature_mask=$(get_header_kv $prefix features int 0 1)
  echo -e "feature-mask:\t$feature_mask"
  
  # evaluate if rbd_feature_names is active
  for ((i=$features_max; i>=0; i--)); do
    value=$((2**$i))
    if [ $feature_mask -ge $value ]; then
	rbd_feature_value[$i]=1
	features_active=$(($features_active+1))
	feature_mask=$((feature_mask-value))
    fi
  done

  # create comma seperated list of active rbd_feature_names
  y=0;
  for ((i=0; i<$features_max; i++)); do
    if [ ${rbd_feature_value[$i]} = 1 ]; then
	y=$((y+1))
	if [ $y -lt $features_active ]; then
	    feature_list="$feature_list${rbd_feature_name[$i]}, "
	else
	  feature_list="$feature_list${rbd_feature_name[$i]}"
	fi
    fi
  done
  
  echo -e "feature_list:\t(${feature_list})"

  # if striping is enabled, get stripe_unit and stript_count
  # https://github.com/ceph/ceph/blob/master/src/cls/rbd/cls_rbd.cc#L679
  # uint64_t stripe_unit;
  # uint8_t stripe_unit;
  stripe_unit=1
  if [ $debug ]; then
    echo -e "rbd_feature_value:\t(${rbd_feature_name[1]} -> ${rbd_feature_value[1]})"
  fi
  if [ ${rbd_feature_value[1]} = 1 ]; then
      stripe_unit=$(get_header_kv $prefix stripe_unit int 0 5)
      stripe_count=$(get_header_kv $prefix stripe_count int 0 1)
      echo -e "stripe_unit:\t$stripe_unit"
      echo -e "stripe_count:\t$stripe_count"
  #else
  #    echo -e "stripe_unit:\t$stripe_unit (default)"
  fi
}

function list_snapshots_v2()
{
  # ~ceph/ceph/tree/master/src/include/rbd/librbd.h
  # typedef struct {
  #   uint64_t id;
  #   uint64_t size;
  #   const char *name;
  # } rbd_snap_info_t;

  # struct cls_rbd_snap {
  # 	snapid_t id;
  #	string   name;
  #	uint64_t image_size;
  #	uint64_t features;
  #	uint8_t  protection_status;
  #	cls_rbd_parent parent;
  # }

  # Decode the binary representation:
  # decode cls_rbd_snap
  # 1	u8	struct_v
  # 1	u8	struct_compat
  # 4	u32	struct_len
  # 8	u64	snapid_t id //s=6 n=8
  # 4	u32	len of name //s=14 n=4
  # len	char	name        //s=18 n=len
  # 8	u64	image_size
  # 8	u64	features
  # ......

  local func="list_snapshots_v2"
  if [ "$1"x = ""x ]; then
      echo "$func: ceph-kvstore-tool missing parameter <meta_header_seq>"
      exit
  fi
  local sname=
  if [ $# -eq 2 ]; then
      sname=$2
  fi
  if [ $debug ]; then
      echo "$func: snapshot-name='$sname'"
  fi
  local meta_header_seq=`printf "%016d" $1`
  local prefix="_USER_"$meta_header_seq"_USER_"

  # debug from here on!
  return
  local keys=(`awk -F ":" '/snapshot_/ && $1 == "'"$prefix"'" {if ($2 == "") exit; split($2, arr, "_"); 
	print arr[2];}' $omap_list|sort -r`)
  local tmp_snap=/tmp/tmp_snap.$$$$

  echo -e "\t\tID\tNAME\t\tSIZE"
  for key in ${keys[@]}
  do
    key="snapshot_$key"
    ceph-kvstore-tool $omap_path get $prefix $key out $tmp_snap 2>/dev/null >/dev/null
    local arr=`cat $tmp_snap |awk -F ":" '{print $2}'`
    #local arr=(`ceph-kvstore-tool $omap_path get $prefix $key|awk -F ":" '{print $2}'`);
    if [ $debug ]; then
	echo "$func: tmp_snap="
	cat $tmp_snap	
	echo "array: $arr"
    fi

    ###
    # wip: refactor from here on!
    ###
    
    # get snap_name
    tmp=
    for ((i=17; i>13; i--))
    do
      tmp="$tmp${arr[$i]}"
    done
    local len=$((16#$tmp))
    local snap_name=
    for ((i=18; i<$((18+$len)); i++))
    do
      # convert ascii to char
      local char=`echo -e "\x${arr[$i]}"` 
      snap_name="$snap_name$char"
    done
    # get snap_id (little endian)
    local tmp=
    for ((i=13; i>5; i--))
    do
      tmp="$tmp${arr[$i]}" 
    done
    local snap_id=$((16#$tmp))
    # get image_size of current snap (little endian)
    tmp=
    for ((i=$((25+$len)); i>$((17+$len)); i--))
    do
      tmp="$tmp${arr[$i]}"
    done
    local image_size=$((16#$tmp))
    if [ "$sname"x = ""x ]; then
	echo -e "snapshot:\t$snap_id\t$snap_name\t\t$image_size" 
	continue
    fi
    if [ "$sname"x = "$snap_name"x ]; then
	echo -e "snapshot:\t$snap_id\t$snap_name\t\t$image_size" 
	return
    fi
  done
}

#======================================== end image format v2 ========================================  
