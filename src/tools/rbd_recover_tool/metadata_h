# -*- mode:sh; tab-width:8; sh-basic-offset:2; indent-tabs-mode:t -*-
# vim: ts=8 sw=2 smarttab

#!/bin/bash
# file: metadata_h
#
# Copyright (C) 2015-2017 Ubuntu Kylin
#
# Author:   Min Chen <minchen@ubuntukylin.com>
# Extended: Ralf Zerres <ralf.zerres@networkx.de>

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

my_dir=$(dirname "$0")

. $my_dir/epoch_h
. $my_dir/common_h

# put origin name in $image_name_in: for output
# put convert "_" name in $image_name: for grep image hobjects from database
image_name_in=
image_name=
function input_image()
{
  local func="input_image"
  if [ "$1"x = ""x ]; then
      echo "$func: no image name input"
      exit
  fi
  
  image_name_in=$1
  # "_" -> "\u"
  image_name=`convert_underline $image_name_in`
}

#======================================== distinguish v1 or v2 ===================================  
#image_list_v1=$single_node/$cluster-$id/image_list_v1
#image_list_v2=$single_node/$cluster-$id/image_list_v2
function get_image_list()
{
  find $osd_data/current/ -type f -regex '.*/rbd__.*' >$image_list_v1
  find $osd_data/current/ -type f -regex '.*/rbd.\uid.*' >$image_list_v2
}

function get_image_format_by_hobject()
{
  local func="get_image_format"
  if [ "$1"x = ""x ]; then
      exit
  fi
  local res1=`cat $image_list_v1|grep $1`  
  if [ "$res1"x != ""x ]; then
      echo 1
      exit
  fi  
  
  local res2=`cat $image_list_v2|grep  $1`
  if [ "$res2"x = ""x ]; then
      echo 2
      exit
  fi
}

#======================================== image format v1 ========================================  
# /*
#  * old-style rbd image 'foo' consists of objects
#  *   foo.rbd      - image metadata
#  *   rb.<idhi>.<idlo>.00000000
#  *   rb.<idhi>.<idlo>.00000001
#  *   ...          - data
#  */

# <image_name>.rbd inlude 3 parts:

# header + snap_count*snapshot + snap_count*snap_name
# 
# struct rbd_obj_header_ondisk {
# 40	char text[40];
# 24	char block_name[RBD_MAX_BLOCK_NAME_SIZE];
# 4	char signature[4];
# 8	char version[8];
# 	struct {
# 1		__u8 order;
# 1		__u8 crypt_type;
# 1		__u8 comp_type;
# 1		__u8 unused;
# 	} __attribute__((packed)) options;
# 8	__le64 image_size;//hexdump -C s=80 n=8
# 8	__le64 snap_seq;  //hexdump -C s=88 n=8
# 4	__le32 snap_count;//hexdump -C s=96 n=4
# 4	__le32 reserved;
# 8	__le64 snap_names_len; //hexdump -C s=104 n=8
# 	struct rbd_obj_snap_ondisk snaps[0];
# } __attribute__((packed));
#
# sizeof(rbd_obj_header_ondisk): 112
#
# struct rbd_obj_snap_ondisk {
# 8	__le64 id;             //hexdump -C s=112+i*16 n=8   , i=[0, snap_count)
# 8	__le64 image_size;     //hexdump -C s=112+i*16+8 n=8, i=[0, snap_count)
# } __attribute__((packed));
# sizeof(rbd_obj_snap_ondisk): 16
#
# get snap_names form <image_name>.rbd
# hexdump -e '10/1 "%_c"' -s $((112 + $snap_count*16)) -n $snap_names_len <image_name>.rbd
# then split snap_names into array

function get_image_metadata_v1()
{
  local func="get_image_metadata_v1"
  if [ "$1"x = ""x ]; then
      echo "$func: no image head object input"
      exit
  fi
  local snap_name=
  if [ "$2"x != ""x ]; then
      snap_name=$2 
  fi
  
  if [ ! -e $1 ]; then
      echo "$func: $1 not exists"
      exit
  fi
  local hobject_path=$1  
  d_hobject_path=`dump_backslash $1`
  local image_format=`get_image_format_by_hobject $d_hobject_path`
  if [ $image_format != 1 ]; then
      echo "$func: image_format must be 1"
      exit
  fi
  
  if [ ! -e $hobject_path ]; then
      echo "$func: $hobject_path not exists"
      exit
  fi

  # decode rbd_obj_header_ondisk of <image_name>.rbd
  local image_prefix=`hexdump -e '10/1 "%c"' -s 40 -n 24 $hobject_path`
  local order=`hexdump -e '10/4 "%u"' -s 76 -n 1 $hobject_path`
  local image_size=`hexdump -C -s 80 -n 8 $hobject_path|head -n 1|awk '{for (i=9; i>1; i--) {printf $i}}'`
  image_size=$((16#$image_size))
  local snap_seq=`hexdump -C -s 88 -n 8 $hobject_path|head -n 1|
	awk '{num=""; for(i=9; i>1; i--){ num=num""$i;} print strtonum("0x"num);}'`
  local snap_count=`hexdump -C -s 96 -n 4 $hobject_path|head -n 1|
	awk '{num=""; for(i=5; i>1; i--){ num=num""$i;} print strtonum("0x"num);}'` 
  local snap_names_len=`hexdump -C -s 104 -n 8 $hobject_path|head -n 1|
	awk '{num=""; for(i=9; i>1; i--){ num=num""$i;} print strtonum("0x"num);}'` 

  echo -e "image_prefix:\t$block_name"
  echo -e "order:\t\t$order"
  echo -e "image_size:\t$image_size"
  echo -e "snap_seq:\t$snap_seq"

  # decode N rbd_obj_snap_ondisk of <image_name>.rbd
  declare -a snap_ids
  declare -a snap_names
  declare -a snap_image_sizes
  local size_header=112 #sizeof(rbd_obj_header_ondisk)
  local size_snap=16 #sizeof(rbd_obj_snap_ondisk)
  local offset=0
  local id_off=0
  local size_off=0
  for ((i=0; i<$snap_count; i++))
  do
    offset=$(($size_header + $i * $size_snap)) 
    id_off=$offset 
    size_off=$(($offset + 8))
    snap_ids[$i]=`hexdump -C -s $id_off -n 8 $hobject_path|head -n 1|
	awk '{num=""; for(i=9; i>1; i--){num=num""$i;} print strtonum("0x"num);}'`
    snap_image_sizes[$i]=`hexdump -C -s $size_off -n 8 $hobject_path|head -n 1|
	awk '{num=""; for(i=9; i>1; i--){num=num""$i;} print strtonum("0x"num);}'`
  done
  offset=$(($size_header + $snap_count * $size_snap))
  snap_names=(`hexdump -e '10/1 "%_c"' -s $offset -n $snap_names_len $hobject_path|
  	awk -F "\\\\\\\\\\\\\\\\0" '{for(i=1; i<=NF; i++) {print $i" "} }'`); 

  echo -e "\t\tID\tNAME\t\tSIZE"
  for ((i=0; i<$snap_count; i++))
  do
    if [ "$snap_name"x = ""x ]; then
	echo -n -e "snapshot:\t"
	echo -e "${snap_ids[$i]}\t${snap_names[$i]}\t\t${snap_image_sizes[$i]}"
	continue
    fi
    if [ "$snap_name"x = "${snap_names[$i]}"x ]; then 
	echo -n -e "snapshot:\t"
	echo -e "${snap_ids[$i]}\t${snap_names[$i]}\t\t${snap_image_sizes[$i]}"
	return
    fi
  done
}

#======================================== end image format v1 ========================================  

#======================================== image format v2 ======================================== 

# /* New-style rbd image 'foo' consists of objects
#  *   rbd_id.foo              - id of image
#  *   rbd_header.<id>         - image metadata
#  *   rbd_object_map.<id>     - optional image object map
#  *   rbd_data.<id>.00000000
#  *   rbd_data.<id>.00000001
#  *   ...                     - data objects
#  */

# /* Metadata is stored in the object-map and decrypted with ceph-kvstore-tool tool
#  * rbd_header.<id>...head.<pool>.<seq> object extracted via get_header_map/get_header_meta_seq
#  * key/value: ceph-kvstore-tool kvdb-type /storepath/to/omap list _USER_<16digits>_USER_
#  *            generic attributes: object_prefix;order;size;features;snap_seq
#  *            feature-specific:   stripe_unit;stripe_count;snapshot;parent
#  *
#  */
# /* Metadata Definitions: https://github.com/ceph/ceph/blob/master/src/tools/rbd_recover_tool/metadata_h#L192
#  * for image format 2: map_header, meta_header_seq, header, key/value
#  * eg. 
#  * map_header  	_HOBJTOSEQ_:rbd%uheader%e139a6b8b4567...head.2.68E826B6
#  * meta_header_seq:	17426
#  * header:	        _USER_0000000000017426_USER_:object_prefix
#  *			_USER_0000000000017426_USER_:order
#  *			_USER_0000000000017426_USER_:size
#  *			_USER_0000000000017426_USER_:snap_seq
#  *			_USER_0000000000017426_USER_:snapshot
#  *			_USER_0000000000017426_USER_:features
#  *			_USER_0000000000017426_USER_:_epoch
#  *			_USER_0000000000017426_USER_:_biginfo
#  *			_USER_0000000000017426_USER_:_info
#  *			_USER_0000000000017426_USER_:_infover
#  *                    key                         :value
#  * ceph-kvstore-tool leveldb /path_to_omap/omap _USER_0000000000017426_USER_ size)
#  */


# get header info key/value
function get_header_kv()
{
  local func="get_header_kv"
  local prefix=$1
  local key=$2
  local type=$3
  local seek=$4
  local len=$5
  local res=/tmp/kv.$$$$
  local hexvalue
  local value
  
  if [ -z $prefix ]; then
      if [ $debug ]; then
	  echo "$func: ceph-kvstore-tool needs a valid object prefix"
      fi
      exit
  elif [ -z $key ]; then
    if [ $debug ]; then
      echo "$func: ceph-kvstore-tool needs a valid key "
    fi
    exit
  elif [ "$type"x != "int"x ] && [ "$type"x != "le_int"x ] && [ "$type"x != "string"x ]; then
    if [ $debug ]; then
      echo "$func: ceph-kvstore-tool need a valid input type (string|int|le_int)"
    fi
    exit
  fi

  # values are dumped in hex (big-endian format)
  #ceph-kvstore-tool $kvdb_type $omap_path get $prefix $key 2>/dev/null 1>$res
  ceph-kvstore-tool $kvdb_type $omap_path get $prefix $key out $res 2>/dev/null 1>/dev/null
  if [ $? != 0 ]; then
    if [ $debug ]; then
      echo "$func: error -> ceph-kvstore-tool $kvdb_type $omap_path get $prefix $key"
    fi
    exit
  fi

  if [ "$type"x = "string"x ]; then
    # process dump: offset 4, switch next 24 octets
    test -z $seek && seek=4;
    test -z $len && len=24;
    value=`xxd -seek $seek -len $len -p $res | xxd -r -p`
  elif [ "$type"x = "int"x ]; then
    test -z $seek && seek=0;
    test -z $len && len=8;
    hexvalue=`xxd -seek $seek -len $len -p $res`
    value=`printf "%d" 0x$hexvalue`
  elif [ "$type"x = "le_int"x ]; then
    # use little endian conversion
    test -z $seek && seek=0;
    test -z $len && len=4;
    hexvalue=`xxd -seek $seek -len $len -e $res | \
       awk 'BEGIN { -F ":" } { print $2; }'`
    value=`printf "%d" 0x$hexvalue`
  fi
  #if [ $debug ]; then
  #    echo "\n[debug] $func: key: $prefix -> value: $value>"
  #fi
  rm -f $res
  echo $value
}

function get_header_seq()
{
  #use ceph-kvstore-tool to extract seq-position
  local func="get_header_seq"
  if [ "$1"x == ""x ]; then
      echo "$func: ceph-kvstore-tool missing parameter <prefix>"
      exit;
  elif [ "$2"x == ""x ]; then
      echo "$func: ceph-kvstore-tool missing parameter <key>"
      exit;
  fi
  local prefix=$1;
  local key=$2;
  local res=/tmp/header_seq.$$$$
  local hexseq
  local seq
  
  # ceph-kvstore-tool dumps values in hex (big-endian format)
  # ($key, $value)
  # (_HOBJTOSEQ_, ...head.0.00000011)
  # 00000000  02 01 81 00 00 00 87 e4  12 00 00 00 00 00 00 00
  # relevant seq is coded in uint64: 8 bytes (big-endian):
  # -> 00 00 00 00 00 87 E4 12
  # => 12 e4 87 00 00 00 00 00 
  # use xxd to process the hex dump
  # finally transform the hex output to the needed integer
  # header_seq = echo $((16#000000000012e487)) -> 1238151
  ceph-kvstore-tool $kvdb_type $omap_path get $prefix $key out $res 2>/dev/null 1>/dev/null
  if [ $? != 0 ]; then
      exit;
  fi
  
  # process dump: offset 6, switch next 8 octets to little endian 
  hexseq=`xxd -seek 6 -len 8 -e $res | \
       awk 'BEGIN { -F ":" } { print $2; }'`
  seq=`printf "%d" 0x$hexseq`
  if [ "$seq"x = ""x ]; then
    exit;
  fi
  rm -f $res
  echo $seq
}

function get_image_features()
{
  ###
  # parse the given feature_mask
  ###
  local func="get_image_features"
  local ghobject_key=$1
  local feature_mask=$2
  if [ "$ghobject_key"x = ""x ]; then
      echo "$func: missing parameter <ghobject_key>"
      exit
  fi
  if [ "$feature_mask"x = ""x ]; then
      echo "$func: missing parameter <feature_mask>"
      exit
  fi
  if [ $verbose ]; then
      echo "$func: parse feature-mask ..."
  fi
  if [ $debug ]; then
      echo -e "$func: feature-mask -> $feature_mask"
  fi
  
  # Source definitions: /src/include/rbd/features.h
  #define RBD_FEATURE_LAYERING             (1ULL<<0)
  #define RBD_FEATURE_STRIPINGV2           (1ULL<<1)
  #define RBD_FEATURE_EXCLUSIVE_LOCK       (1ULL<<2)
  #define RBD_FEATURE_OBJECT_MAP           (1ULL<<3)
  #define RBD_FEATURE_FAST_DIFF            (1ULL<<4)
  #define RBD_FEATURE_DEEP_FLATTEN         (1ULL<<5)
  #define RBD_FEATURE_JOURNALING           (1ULL<<6)
  #define RBD_FEATURE_DATA_POOL            (1ULL<<7)
  
  #define RBD_FEATURE_NAME_LAYERING        "layering"
  #define RBD_FEATURE_NAME_STRIPINGV2      "striping"
  #define RBD_FEATURE_NAME_EXCLUSIVE_LOCK  "exclusive-lock"
  #define RBD_FEATURE_NAME_OBJECT_MAP      "object-map"
  #define RBD_FEATURE_NAME_FAST_DIFF       "fast-diff"
  #define RBD_FEATURE_NAME_DEEP_FLATTEN    "deep-flatten"
  #define RBD_FEATURE_NAME_JOURNALING      "journaling"
  #define RBD_FEATURE_NAME_DATA_POOL       "data-pool"

  # sum   255     all features set
  # sum   125     layering,exclusive-lock,object-map,fast-diff,deep-flatten,journaling
  # sum    61     layering,exclusive-lock,object-map,fast-diff,deep-flatten

  local rbd_feature_name_layering="layering"
  local rbd_feature_name_striping="striping"
  local rbd_feature_name_exclusive_lock="exclusive-lock"
  local rbd_feature_name_object_map="object-map"
  local rbd_feature_name_fast_diff="fast-diff"
  local rbd_feature_name_deep_flatten="deep-flatten"
  local rbd_feature_name_journaling="journaling"
  local rbd_feature_name_data_pool="data-pool"

  # bash has no multidemensional arrays,
  # we rely on a assosiative declaration
  declare -a rbd_feature_name
  rbd_feature_name=(
    $rbd_feature_name_layering
    $rbd_feature_name_striping
    $rbd_feature_name_exclusive_lock
    $rbd_feature_name_object_map
    $rbd_feature_name_fast_diff
    $rbd_feature_name_deep_flatten
    $rbd_feature_name_journaling
    $rbd_feature_name_data_pool
  )

  local features_max=${#rbd_feature_name[@]}
  local feature_list
  local features_active=0

  declare -a rbd_feature_value
  eval "rbd_feature_value=( $(for ((i=0; i<$features_max; i++)) do echo 0; done) )"

  # evaluate if rbd_feature_name is active
  for ((i=$features_max; i>=0; i--)); do
    value=$((2**$i))
    if [ $feature_mask -ge $value ]; then
	rbd_feature_value[$i]=1
	features_active=$(($features_active+1))
	feature_mask=$((feature_mask-value))
    fi
  done

  # create comma seperated list of active rbd_feature_names
  y=0;
  for ((i=0; i<$features_max; i++)); do
    if [ ${rbd_feature_value[$i]} = 1 ]; then
	y=$((y+1))
	if [ $y -lt $features_active ]; then
	    feature_list="$feature_list${rbd_feature_name[$i]}, "
	else
	  feature_list="$feature_list${rbd_feature_name[$i]}"
	fi
    fi
  done
  
  echo -e "feature_list:\t${feature_list}"

  # if striping is enabled, get stripe_unit and stript_count
  # https://github.com/ceph/ceph/blob/master/src/cls/rbd/cls_rbd.cc#L679
  # uint64_t stripe_unit;
  # uint8_t stripe_unit;
  if [ $debug ]; then
    echo -e "$func: ${rbd_feature_name[1]} -> ${rbd_feature_value[1]}"
  fi
  if [ ${rbd_feature_value[1]} = 1 ]; then
      stripe_count=$(get_header_kv $ghobject_key stripe_count int 0 1)
      stripe_unit=$(get_header_kv $ghobject_key stripe_unit int 0 5)
      if [ -n stripe_unit ]; then
	echo -e "stripe_unit:\t$stripe_unit"
	echo -e "stripe_count:\t$stripe_count"
      else
	stripe_unit=1
	echo -e "stripe_unit:\t$stripe_unit (default)"
      fi
  fi

  # if layering is enabled, check for parent attributes
  if [ $debug ]; then
    echo -e "$func: ${rbd_feature_name[0]} -> ${rbd_feature_value[0]}"
  fi
  if [ ${rbd_feature_value[0]} = 1 ]; then
      get_image_parent $ghobject_key
  fi
}

# decode image id from image_id_hobject 
function get_image_id()
{
  local func="get_image_id"
  if [ "$1"x = ""x ]; then
      exit;
  fi
  local image_id_hobject=$1 #from admin node's database

  if [ ! -e $image_id_hobject ]; then
      echo "$func: given rados object id <$image_id_hobject> does not exist"
      exit;
  fi
  
  # get len of string (offset 0, 4 fields)  
  #local n=`hexdump -e '10/4 "%u"' -s 0 -n 4 $image_id_hobject`
  #hexdump -e '10/1 "%c"' -s 4 -n $n $image_id_hobject
  local lenhex=`xxd -seek 0 -len 1 -p $image_id_hobject`
  local len=$((16#$lenhex))
  xxd -seek 4 -len $len -p $image_id_hobject | xxd -p -r
}

function get_image_metadata_v2()
{
  # https://github.com/ceph/ceph/tree/master/src/include/rbd/librbd.h#L89
  # typedef struct {
  # uint64_t size;
  # uint64_t obj_size;
  # uint64_t num_objs;
  # int      order;
  # char     block_name_prefix[RBD_MAX_BLOCK_NAME_SIZE]; /* deprecated */
  # int64_t  parent_pool;			         /* deprecated */
  # char     parent_name[RBD_MAX_IMAGE_NAME_SIZE];       /* deprecated */
  #} rbd_image_info_t;

  # /* image options */
  # enum {
  #  RBD_IMAGE_OPTION_FORMAT = 0,
  #  RBD_IMAGE_OPTION_FEATURES = 1,
  #  RBD_IMAGE_OPTION_ORDER = 2,
  #  RBD_IMAGE_OPTION_STRIPE_UNIT = 3,
  #  RBD_IMAGE_OPTION_STRIPE_COUNT = 4,
  #  RBD_IMAGE_OPTION_JOURNAL_ORDER = 5,
  #  RBD_IMAGE_OPTION_JOURNAL_SPLAY_WIDTH = 6,
  #  RBD_IMAGE_OPTION_JOURNAL_POOL = 7,
  #  RBD_IMAGE_OPTION_FEATURES_SET = 8,
  #  RBD_IMAGE_OPTION_FEATURES_CLEAR = 9,
  #  RBD_IMAGE_OPTION_DATA_POOL = 10
  #};

  # CEPH_RBD_API int rbd_image_options_is_set(rbd_image_options_t opts,
  #                                           int optname, bool* is_set);  

  local func="get_image_metadata_v2"
  if [ "$1"x = ""x ]; then
      echo "$func: ceph-kvstore-tool missing parameter <meta_header_seq>"
      exit;
  fi
  # aline to 16 digets
  local meta_header_seq=`printf "%016d" $1`
  if [ $debug ]; then
      echo "$func: meta_header_seq = $meta_header_seq"
  fi
  local ghobject_key="_USER_"$meta_header_seq"_USER_"
  if [ $debug ]; then
      echo "$func: ghobject_key = $ghobject_key"
  fi

  object_prefix=$(get_header_kv $ghobject_key object_prefix string 4 24)
  order=$(get_header_kv $ghobject_key order int 0 1)
  image_size=$(get_header_kv $ghobject_key size int 0 8)
  snap_seq=$(get_header_kv $ghobject_key snap_seq int 0 1)
  echo -e "object_prefix:\t$object_prefix"
  echo -e "order (2^x):\t$order"
  echo -e "object-size:\t$((2**$order/1024)) KBytes"
  echo -e "image_size:\t$(($image_size/1024)) KBytes ($(($image_size/1024/1024)) MBytes)"
  echo -e "image_objects:\t$(($image_size/$((2**$order/1024))))"

  # parse features
  feature_mask=$(get_header_kv $ghobject_key features int 0 1)
  echo -e "feature_mask:\t$feature_mask"
  get_image_features $ghobject_key $feature_mask
  
  # list snapshot
  get_image_snapshots $ghobject_key $2
  #echo -e "snap_seq:\t$snap_seq"
}
  
function get_image_parent()
{
  local func="get_image_parent"
  local ghobject_key=$1
  if [ "$ghobject_key"x = ""x ]; then
      echo "$func: missing parameter <ghobject_key>"
      exit
  fi
  if [ $verbose ]; then
      echo "$func: parse parent attributes ..."
  fi

  ###
  # get parent attributes
  ###
  # https://github.com/ceph/ceph/blob/master/src/cls/rbd/cls_rbd.h#L12
  # struct cls_rbd_parent {
  #   int64_t pool;        ///< parent pool id
  #   string id;           ///< parent image id
  #   snapid_t snapid;     ///< parent snapid we refer to
  #   uint64_t overlap;    ///< portion of this image mapped onto parent (bytes)
  #
  #   /// true if our parent pointer information is defined
  #   bool exists() const {
  #     return snapid != CEPH_NOSNAP && pool >= 0 && id.length() > 0 && overlap > 0;
  #   }
  
  # Decode the binary representation:
  # DECODE _START(5,p) -> we decode at 6
  # bl  type    name
  # 1	u8	struct_v
  # 1	u8	struct_compat
  # 1	u8	struct_len       //s=2 l=1 
  # 4	u64	pool_id          //s=3 l=4
  # 6	u64	??????           //s=8 l=6
  # 13	u8	parent_name_len  //s=14 l=1
  # 15	u64     ??????           //s=15 l=3
  # xx	char	parent_name      //s=18 l=$parent_name_len
  # 1	u8	parent_snap_id   //s=18+$parent_name_len l=1
  # 8	u64	overlap          //s=18+$parent_name_len+8+1 l=4
  # 8	u8	parent_protect   //s=18+$parent_name_len+8+4 l=1
  # ......
  parent_stuct_len=$(get_header_kv $ghobject_key parent int 2 1)
  parent_id_len=$(get_header_kv $ghobject_key parent int 14 1)
  if [ "$parent_id_len"x != ""x ]; then
      parent_pool_id=$(get_header_kv $ghobject_key parent int 3 4)
      parent_id=$(get_header_kv $ghobject_key parent string 18 $parent_id_len)
      parent_snap_id=$(get_header_kv $ghobject_key parent int $((18+$parent_id_len)) 1)
      parent_overlap=$(get_header_kv $ghobject_key parent int $((18+$parent_id_len+8+1)) 4)
      parent_protect=$(get_header_kv $ghobject_key parent int $((18+$parent_id_len+8+4)) 1)
      echo -e "parent_pool_id:\t$parent_pool_id"
      echo -e "parent_id_len:\t$parent_id_len"
      echo -e "parent_id:\t$parent_id"
      echo -e "parent_snap_id:\t$parent_snap_id"
      echo -e "parent_protect:\t$parent_protect"
      echo -e "parent_overlap:\t$parent_overlap"
  fi
  
  if [ $debug ]; then
      local ghobject_value=/tmp/kv.ghobject_value
      ceph_kvstore_tool $kvdb_type $omap_path get $ghobject_key parent out $ghobject_value 2>/dev/null
      echo get_value="ghobject_value"
      xxd -p $ghobject_value
  fi
}

function get_image_snapshots()
{
  ###
  # get snapshot attributes
  ###
  # https://github.com/ceph/ceph/tree/master/src/include/rbd/librbd.h#L67
  # typedef struct {
  #   uint64_t id;
  #   uint64_t size;
  #   const char *name;
  # } rbd_snap_info_t;

  # https://github.com/ceph/ceph/blob/master/src/cls/rbd/cls_rbd.h#L60
  # struct cls_rbd_snap {
  #   snapid_t id;
  #   string name;
  #   uint64_t image_size;
  #   uint64_t features;
  #   uint8_t protection_status;
  #   cls_rbd_parent parent;
  #   uint64_t flags;
  #   cls::rbd::SnapshotNamespaceOnDisk snapshot_namespace;
  #
  #   /// true if we have a parent
  #   bool has_parent() const {
  #     return parent.exists();
  # }


  # Decode the binary representation:
  # https://github.com/ceph/ceph/blob/master/src/cls/rbd/cls_rbd.h#L91
  # DECODE _START(5,p) -> we decode at 6
  # bl  type    name
  # 1	u8	struct_v
  # 1	u8	struct_compat
  # 4	u32	struct_len
  # 8	u64	snapid_t id        //s=3 n=4
  # 4	u32	name_len           //s=14 n=1
  # xx	char	name               //s=18 n=name_len
  # 8	u64	overlap_size       //s=18+len n=len
  # 8	u64	features           //s=18+len+8 n=1
  # 8   u8      protection_status  //s=18+len+16 n=1
  # ......

  local func="get_image_snapshots"
  if [ "$1"x = ""x ]; then
      echo "$func: ceph-kvstore-tool missing parameter <header_meta_seq>"
      exit
  fi
  local ghobject_key=$1
  local sname=
  if [ $# -eq 2 ]; then
      sname=$2
  fi
  if [ $debug ]; then
      echo "$func: snapshot-name='$sname'"
  fi

  local values=(`awk -F ":" '/snapshot_/ && $1 == "'"$ghobject_key"'" {if ($2 == "") exit; split($2, arr, "_"); 
	print arr[2];}' $omap_list|sort -r`)

  if [ ${#values[*]} -gt 0 ]; then
      if [ $debug ]; then
	  echo "$func: array snapshot-values: size=${#values[*]} elements='${values[@]}'"
      fi
      #echo -e "snapshots\tID\tNAME\t\tSIZE"
      for value in ${values[@]}
      do
	if [ $debug ]; then
	    echo -e "snapshot-count:\t${#values[*]}"
	fi
	svalue="snapshot_$value"
	#snap_name_len=$(get_header_kv $ghobject_key $svalue int 7 8)
	snap_name_len=$(get_header_kv $ghobject_key $svalue int 14 1)
	snap_name=$(get_header_kv $ghobject_key $svalue string 18 $snap_name_len)
	case "$sname"x in
	  x) # list all available snapshots
	    snap_struct_v=$(get_header_kv $ghobject_key $svalue int 0 1)
	    snap_struct_len=$(get_header_kv $ghobject_key $svalue int 2 1)
	    snap_id=$(get_header_kv $ghobject_key $svalue int 3 4)
	    snap_protection_status=$(get_header_kv $ghobject_key $svalue int $((18+$snap_name_len+3)) 1)
	    snap_features=$(get_header_kv $ghobject_key $svalue int $((18+$snap_name_len+8)) 1)
	    overlap_size=$(get_header_kv $ghobject_key $svalue le_int $((18+$snap_name_len+8+5)) 4)
	    #snap_size=$(get_header_kv $ghobject_key $svalue le_int $((18+$snap_name_len+8+5)) 4)
	    echo "### begin ->  snapshot-metadata @$snap_name"
	    echo -e "snap_name:\t$snap_name"
	    echo -e "snap_id:\t$snap_id"
	    echo -e "snap_name_len:\t$snap_name_len"
	    snap_protection_status=$(get_header_kv $ghobject_key $svalue int $((18+$snap_name_len+3)) 1)
	    snap_features=$(get_header_kv $ghobject_key $svalue int $((18+$snap_name_len+8)) 1)
	    overlap_size=$(get_header_kv $ghobject_key $svalue le_int $((18+$snap_name_len+8+5)) 4)
	    #snap_size=$(get_header_kv $ghobject_key $svalue le_int $((18+$snap_name_len+8+5)) 4)
	    echo "### begin -> snapshot-metadata: @$snap_name"
	    echo -e "snap_name:\t$snap_name"
	    echo -e "snap_id:\t$snap_id"
	    echo -e "snap_struct_v:\t$snap_struct_v"
	    echo -e "snap_struct_l:\t$snap_struct_len"
	    echo -e "snap_name_len:\t$snap_name_len"
	    echo -e "overlap_size:\t$(($overlap_size/1024)) KBytes"
	    #echo -e "snap_size:\t$snap_size Bytes ($(($snap_size/1024/1024)) GBytes)"
	    #echo -e "snap_order (2^x):\t$order"
	    #echo -e "image_objects:\t$(($image_size/$((2**$order/1024))))"
	    echo -e "protect:\t$snap_protection_status"
	    echo -e "snap_features:\t$snap_features"
	    get_image_features $ghobject_key $snap_features
	    break
	    ;;
	esac
      done  # for value in ${values[@]}
      if [ $debug ]; then
	  echo "### end -> snapshot-metadata"
      fi
  else
    if [ $debug ]; then
	echo "$func: no snapshots found."
    fi
  fi
}

#find image_id omap entry in omaplist
map_header_key=
map_header_value=
function get_map_header()
{
  local func="get_map_header"
  local image_id=$1
  if [ "$image_id"x = ""x ]; then
      echo "$func: ceph-kvstore-tool missing parameter <image_id>"
      exit;
  fi
  map_header_key=`get_map_header_key`
  local keyword="header%e"$image_id
  map_header_value=`get_map_header_value $keyword`
  if [ "$map_header_value"x = ""x ]; then
      echo "$func: map_header_value is NULL (can't get from not omap list)"
      exit
  fi
  if [ $debug ]; then
      echo "$func: map_header_value: $map_header_value"
  fi
}

function get_map_header_key()
{
  echo "_HOBJTOSEQ_"
}

function get_map_header_value()
{
  local func="get_map_header_value"
  if [ "$1"x = ""x ]; then
    echo $func': missing parameter <key>'
    exit 
  fi 
  local keyword=$1
  local res=`cat $omap_list| grep $keyword`
  if [ "$res"x = ""x ]; then
      if [ $debug ]; then
	  echo "$func: omap_list -> key = $keyword does not exist"
      fi
    exit
  fi
  echo $res|awk -F ":" '{print $2}'
}

#get header seq from map_header_key
meta_header_seq=
function get_meta_header_seq()
{
  local func="get_header_meta_seq"
  if [ "$1"x == ""x ]; then
      echo "$func: ceph-kvstore-tool missing parameter <prefix>"
      exit;
  elif [ "$2"x == ""x ]; then
      echo "$func: ceph-kvstore-tool missing parameter <key>"
      exit;
  fi

  local prefix=$1;
  local key=$2;
  meta_header_seq=`get_header_seq $prefix $key`
  if [ $debug ]; then
      echo "$func: meta_header_seq: $meta_header_seq"
  fi
}

#======================================== end image format v2 ========================================  
