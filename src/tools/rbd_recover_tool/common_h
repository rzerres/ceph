# -*- mode:sh; tab-width:8; sh-basic-offset:2; indent-tabs-mode:t -*-
# vim: ts=8 sw=2 smarttab

#!/bin/bash
# file: common_h
#
# Copyright (C) 2015-2017 Ubuntu Kylin
#
# Author:   Min Chen <minchen@ubuntukylin.com>
# Extended: Ralf Zerres <ralf.zerres@networkx.de>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

my_dir=$(dirname "$0")

# ssh option
ssh_option="-o ConnectTimeout=1"

###
# admin node specific
###
# config files
rbd_config=$my_dir/config
osd_host_path=$rbd_config/osd_host_path
mon_host=$rbd_config/mon_host
mds_host=$rbd_config/mds_host

# metadata path
rbd_recover_home=/var/rbd_recover_tool
osd_host=$rbd_recover_home/osd_hosts
osd_host_mapping=$rbd_recover_home/osd_host_mapping
osd_host_data=$rbd_recover_home/osd_host_data
rbd_metadata=$rbd_recover_home/rbd_metadata
database=$rbd_metadata/database
image_coll_v1=$rbd_metadata/image_coll_v1
image_coll_v2=$rbd_metadata/image_coll_v2
pg_coll=$rbd_metadata/pg_coll
images_meta=$rbd_metadata/images_meta
images=$rbd_recover_home/images
kvdb_type=leveldb
default_backup_dir=/var/rbd_recover_tool/default_backup_dir

nosnap= #$rbd_image/<image_name>/nosnap
snap= #rbd_image/<image_name>/<snap_name>

###
# osd node specific
###
job_path=$rbd_recover_home/osd_job
single_node=$rbd_recover_home/single_node
osd_env= #single_node/$cluster$id/osd_env
osd_data= #/var/lib/ceph/osd/$cluster-$id
omap_path= #$osd_data/current/omap

# metadata path
image_list_v1= #single_node/$cluster-$id/image_list_v1
image_list_v2= #single_node/$cluster-$id/image_list_v2
image_v1= #$single_node/$cluster-$id/image_v1
image_v2= #$single_node/$cluster-$id/image_v2
pgid_list= #$single_node/$cluster-$id/pgid_list
node_pg_epoch= #$single_node/$cluster-$id/node_pg_epoch
node_pg_header_seq= #$single_node/$cluster-$id/node_pg_header_seq
omap_list= #$single_node/$cluster-$id/omap_list 


# gen md5sum
function gen_md5()
{
  echo $1|md5sum|awk '{print $1}'
}

# on each osd node
# check ceph enviroment: ssh, ceph-kvstore-tool, osd_data_path 
function check_ceph_env()
{
  local func="check_ceph_env"
  if [ $debug ]; then
      echo "$func: osd-node $node -> verify ceph-structure, availability of ceph-tools"
  fi
  if [ $# -lt 2 ]; then
    echo "$func: parameters: <node> <data_path>" 
    exit
  fi
  local node=$1
  local data_path=$2
  local res=
  local cmd=

  trap 'echo [$node]: ssh failed; exit' INT HUP
  ssh -o ConnectTimeout=1 $node "echo -n" </dev/null
  res=$?
  if [ $res -ne 0 ]; then
    echo "[$node]: ssh failed"
    exit
  fi

  cmd=ceph-kvstore-tool
  trap 'echo [$node]: $cmd failed; exit' INT HUP
  ssh -o ConnectTimeout=1 $node "$cmd &>/dev/null;" </dev/null 
  res=$?
  # ceph-kvstore-tool will return 1 with no parameters input
  if [ $res -ne 1 ]; then
    echo "[$node]: $cmd not installed"
    exit
  fi

  trap 'echo [$node]: stat $data_path failed; exit' INT HUP
  ssh -o ConnectTimeout=1 $node "stat $data_path &>/dev/null;"  </dev/null
  res=$?
  if [ $res -ne 0 ]; then
    echo "[$node]: $data_path does not exists"
    exit
  fi
}

# osd node context : osd_data_path
function init_env_osd()
{
  local func="init_env_osd"
  local host=`hostname`
  osd_data=$1
  if [ "$1"x = ""x ]; then
    echo "$func: missing valid osd_data_path" 
    exit
  fi
  local whoami_path=$osd_data/whoami
  if [ ! -e $whoami_path ]; then
    echo "[$host]: $func: $whoami_path does not exists"
    exit
  fi
  local whoami=`cat $whoami_path`
  omap_path=$osd_data/current/omap

  if [ ! -e $single_node ]; then
    mkdir -p $single_node
  fi

  local osd_id=`gen_md5 $osd_data`
  local osd_dir=$single_node/$osd_id

  if [ ! -e $osd_dir ]; then
      mkdir -p $osd_dir
      ln -s $osd_dir $single_node/osd.$whoami 
  fi
 
  image_list_v1=$osd_dir/image_list_v1
  image_list_v2=$osd_dir/image_list_v2
  image_v1=$osd_dir/image_v1
  image_v2=$osd_dir/image_v2
  pgid_list=$osd_dir/pgid_list
  node_pg_epoch=$osd_dir/node_pg_epoch
  node_pg_header_seq=$osd_dir/node_pg_header_seq
  omap_list=$osd_dir/omap_list
}

function osd_host_path_sort()
{
    local osd_host_path=$1
    local t_host_path_sort=/tmp/tmp_osd_host_sort.$$$$

    if [ "$1"x = ""x ];then
	echo "$func: missing parameter <osd_host_path>"
	exit
    fi

    #cat $osd_host_path | sort -t$'\t' -k 1.1,1 -k 2.24,2.26nr > $t_host_path
    sed -e 's/[[:space:]]*#.*// ; s/[[:space:]]*;;.*// ; /^[[:space:]]*$/d' "$osd_host_path" |
	sort -t$'\t' -k 1.1,1 -k 2.24,2.26nr > $t_host_path_sort
    cp $t_host_path_sort $osd_host_data
    rm $t_host_path_sort
}

# for osd node
function get_omap_list()
{
    if [ $debug ]; then
	echo "get_omap_list: ceph-kvstore-tool $kvdb_type $omap_path list > $omap_list"
    fi	
    ceph-kvstore-tool $kvdb_type $omap_path list >$omap_list 2>/dev/null
}


function convert_underline()
{
  if [ "$1"x = ""x ]; then
    return
  fi

  echo $1|sed -e 's/_/\\u/gp'|head -n 1
}

function dump_backslash()
{
  echo $*|sed -e 's/\\/\\\\/gp'|head -n 1
}

function dump_dump_backslash()
{
  echo $*|sed -e 's/\\/\\\\\\\\/gp'|head -n 1
}

function char_convert()
{
  if [ "$1"x = ""x ]; then
    return
  fi

  echo $1|sed -e 's/_/\\u/gp' -e 's/\./%e/gp' -e 's/%/%p/gp'|head -n 1
}

function check_osd_process()
{
  local func="check_osd_process"
  local host=$1
  if [ "$1"x = ""x ]; then
    exit
  fi

  # why not using systemd?
  #if [ $debug ]; then
  #  echo "check running ceph-osd instances via systemctl"
  #fi
  #if [ `systemctl --host=$host --quiet is-active ceph-osd.target` >= 0 ]; then
  #  systemctl --host=$host stop ceph-osd.target;
  #fi

  local cmds="ps aux|grep ceph-osd|grep -v grep"
  local ret=/tmp/ret.$$$$
  ssh $ssh_option $host $cmds |tee $ret
  if [ -s $ret ]; then
    echo "$func: [$host] ceph-osd process are still active!"
    echo "$func: [$host] we will not proceed to keep intagrity"
    exit
  fi
  rm -f $ret 
}

function get_map_header_prefix()
{
  echo "_HOBJTOSEQ_"
}

function get_map_header_key()
{
  local func="get_map_header_key"
  if [ "$1"x = ""x ]; then
    echo $func': missing parameter <key>'
    exit 
  fi 
  local keyword=$1
  local res=`cat $omap_list| grep $keyword`
  if [ "$res"x = ""x ]; then
      if [ $debug ]; then
	  echo "$func: omap_list -> key = $keyword does not exist"
      fi
    exit
  fi
  echo $res|awk -F ":" '{print $2}'
}

function get_header_seq() 
{
  #use ceph-kvstore-tool to extract seq-position
  local func="get_header_seq"
  if [ "$1"x == ""x ]; then
      echo "$func: ceph-kvstore-tool missing parameter <prefix>"
      exit;
  elif [ "$2"x == ""x ]; then
      echo "$func: ceph-kvstore-tool missing parameter <key>"
      exit;
  fi
  local prefix=$1;
  local key=$2;
  local res=/tmp/header_seq.$$$$
  local hexseq
  local seq
  
  # ceph-kvstore-tool dumps values in hex (big-endian format)
  # ($prefix, $key)
  # (_HOBJTOSEQ_, ...head.0.00000011)
  # 00000000  02 01 81 00 00 00 87 e4  12 00 00 00 00 00 00 00
  # relevant seq is coded in uint64: 8 bytes (big-endian):
  # -> 00 00 00 00 00 87 E4 12
  # => 12 e4 87 00 00 00 00 00 
  # use xxd to process the hex dump
  # finally transform the hex output to the needed integer
  # header_seq = echo $((16#000000000012e487)) -> 1238151
  ceph-kvstore-tool $kvdb_type $omap_path get $prefix $key out $res 2>/dev/null 1>/dev/null
  if [ $? != 0 ]; then
      exit;
  fi
  ### obsolete awk parsing
  #seq=`cat $res |head -n 2|tail -n 1| \
  #awk '
  #BEGIN {
  #  FS="00000000";
  #  seq="";
  #  i=7;
  #} {
  #  split($2, arr, " "); 
  #  # header_seq uint64 : 8 bytes
  #  for (x=7; x>=0; --x) {
  #    seq=seq""arr[i+x];
  #  }
  #}
  #END {
  # print seq
  #}'`
  
  # process dump: offset 6, switch next 8 octets to little endian 
  hexseq=`xxd -seek 6 -len 8 -e $res | \
       awk 'BEGIN { -F ":" } { print $2; }'`
  seq=`printf "%d" 0x$hexseq`
  if [ "$seq"x = ""x ]; then
    exit;
  fi
  rm -f $res
  echo $seq
}

# get header info key/value
function get_header_kv()
{
  local func="get_header_kv"
  local prefix=$1
  local key=$2
  local type=$3
  local seek=$4
  local len=$5
  local res=/tmp/kv.$$$$
  local hexvalue
  local value
  
  if [ -z $prefix ]; then
      if [ $debug ]; then
	  echo "$func: ceph-kvstore-tool needs a valid object prefix"
      fi
      exit
  elif [ -z $key ]; then
      if [ $debug ]; then
	  echo "$func: ceph-kvstore-tool needs a valid key "
      fi
      exit
  elif [ "$type"x != "int"x ] && [ "$type"x != "string"x ]; then
      if [ $debug ]; then
	  echo "$func: ceph-kvstore-tool need a valid input type (string|int)"
      fi
      exit
  fi

  # values are dumped in hex (big-endian format)
  #ceph-kvstore-tool $kvdb_type $omap_path get $prefix $key 2>/dev/null 1>$res
  ceph-kvstore-tool $kvdb_type $omap_path get $prefix $key out $res 2>/dev/null 1>/dev/null
  if [ $? != 0 ]; then
      if [ $debug ]; then
	  echo "$func: error -> ceph-kvstore-tool $kvdb_type $omap_path get $prefix $key"
      fi
      exit
  fi


  if [ "$type"x = "string"x ]; then
    # process dump: offset 4, switch next 24 octets
    test -z $seek && seek=4;
    test -z $len && len=24;
    value=`xxd -seek $seek -len $len -p $res | xxd -r -p`
  elif [ "$type"x = "int"x ]; then
   test -z $seek && seek=0;
   test -z $len && len=8;
   #hexvalue=`xxd -seek $seek -len $len -e -p $res`
   hexvalue=`xxd -seek $seek -len $len -p $res`
   value=`printf "%d" 0x$hexvalue`
  fi
  #if [ $debug ]; then
  #    echo "\n[debug] $func: key: $prefix -> value: $value>"
  #fi
  rm -f $res
  echo $value
  #echo $__result
}
