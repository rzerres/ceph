# -*- mode:sh; tab-width:8; sh-basic-offset:2; indent-tabs-mode:t -*-
# vim: ts=8 sw=2 smarttab

#!/bin/bash
# file: common_h
#
# Copyright (C) 2015-2017 Ubuntu Kylin
#
# Author:   Min Chen <minchen@ubuntukylin.com>
# Extended: Ralf Zerres <ralf.zerres@networkx.de>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

my_dir=$(dirname "$0")

# admin node init path
rbd_image=/var/rbd_tool/rbd_image
database=$rbd_image/database
image_coll_v1=$rbd_image/image_coll_v1
image_coll_v2=$rbd_image/image_coll_v2
pg_coll=$rbd_image/pg_coll
images=$rbd_image/images
images_meta=$rbd_image/images_meta
kvdb_type=leveldb
default_backup_dir=/var/rbd_tool/default_backup_dir

# admin node: image snap & nosnap
nosnap= #$rbd_image/<image_name>/nosnap
snap= #rbd_image/<image_name>/<snap_name>

# osd node init path
job_path=/var/rbd_tool/osd_job
single_node=/var/rbd_tool/single_node

# osd node vars
osd_env= #single_node/$cluster$id/osd_env
osd_data= #/var/lib/ceph/osd/$cluster-$id
omap_path= #$osd_data/current/omap
image_list_v1= #single_node/$cluster-$id/image_list_v1
image_list_v2= #single_node/$cluster-$id/image_list_v2
image_v1= #$single_node/$cluster-$id/image_v1
image_v2= #$single_node/$cluster-$id/image_v2
pgid_list= #$single_node/$cluster-$id/pgid_list
node_pg_epoch= #$single_node/$cluster-$id/node_pg_epoch
node_pg_header_seq= #$single_node/$cluster-$id/node_pg_header_seq
omap_list= #$single_node/$cluster-$id/omap_list 

# admin node config file
osd_host_path=$my_dir/config/osd_host_path
osd_host_mapping= #$pwd_path/config/osd_host_mapping # host --> host_remote: by init_env_admin()
osd_host=$my_dir/config/osd_host #generated by function init_env_admin()
mon_host=$my_dir/config/mon_host
mds_host=$my_dir/config/mds_host

# ssh option
ssh_option="-o ConnectTimeout=1"

# gen md5sum
function gen_md5()
{
  echo $1|md5sum|awk '{print $1}'
}

# on each osd node
# check ceph enviroment: ssh, ceph-kvstore-tool, osd_data_path 
function check_ceph_env()
{
  local func="check_ceph_env"
  if [ $debug ]; then
      echo "$func: osd-node $node -> verify ceph-structure, availability of ceph-tools"
  fi
  if [ $# -lt 2 ]; then
    echo "$func: parameters: <node> <data_path>" 
    exit
  fi
  local node=$1
  local data_path=$2
  local res=
  local cmd=

  trap 'echo [$node]: ssh failed; exit' INT HUP
  ssh -o ConnectTimeout=1 $node "echo -n" </dev/null
  res=$?
  if [ $res -ne 0 ]; then
      echo "[$node]: ssh failed"
      exit
  fi

  cmd=ceph-kvstore-tool
  trap 'echo [$node]: $cmd failed; exit' INT HUP
  ssh -o ConnectTimeout=1 $node "$cmd &>/dev/null;" </dev/null 
  res=$?
  # ceph-kvstore-tool will return 1 with no parameters input
  if [ $res -ne 1 ]; then
      echo "[$node]: $cmd not installed"
      exit
  fi

  trap 'echo [$node]: stat $data_path failed; exit' INT HUP
  ssh -o ConnectTimeout=1 $node "stat $data_path &>/dev/null;"  </dev/null
  res=$?
  if [ $res -ne 0 ]; then
      echo "[$node]: $data_path not exists"
      exit
  fi
}

# osd node context : osd_data_path
function init_env_osd()
{
  local func="init_env_osd"
  local host=`hostname`
  osd_data=$1
  if [ "$1"x = ""x ]; then
    echo "$func: missing valid osd_data_path" 
    exit
  fi
  local whoami_path=$osd_data/whoami
  if [ ! -e $whoami_path ]; then
    echo "[$host]: $func: $whoami_path does not exists"
    exit
  fi
  local whoami=`cat $whoami_path`
  omap_path=$osd_data/current/omap

  if [ ! -e $single_node ]; then
    mkdir -p $single_node
  fi

  local osd_id=`gen_md5 $osd_data`
  local osd_dir=$single_node/$osd_id

  if [ ! -e $osd_dir ]; then
      mkdir -p $osd_dir
      ln -s $osd_dir $single_node/osd.$whoami 
  fi
 
  image_list_v1=$osd_dir/image_list_v1
  image_list_v2=$osd_dir/image_list_v2
  image_v1=$osd_dir/image_v1
  image_v2=$osd_dir/image_v2
  pgid_list=$osd_dir/pgid_list
  node_pg_epoch=$osd_dir/node_pg_epoch
  node_pg_header_seq=$osd_dir/node_pg_header_seq
  omap_list=$osd_dir/omap_list
}

# admin node: cleanup the environment
function cleanup_env_admin()
{
  local func="cleanup_env_admin" 
  local pwd_path=`pwd`
  osd_host_mapping=$pwd_path/config/osd_host_mapping
  if [ ! -s $osd_host_path ]; then
    echo "$func: config/osd_host_path not exists or empty"
    exit
  fi
  if [ -e $rbd_image ]; then
    rm -rf $rbd_image
  fi
  if [ -e $images ]; then
    rm -rf $images
  fi
  if [ -e $osd_host ]; then
    rm -f $osd_host
  fi
  if [ -e $osd_host_mapping ]; then
    rm -f $osd_host_mapping
  fi
}

# admin node process file: osd_host_path
function init_env_admin()
{
  local func="init_env_admin" 
  local pwd_path=`pwd`
  osd_host_mapping=$pwd_path/config/osd_host_mapping
  if [ ! -s $osd_host_path ]; then
      echo "$func: config/osd_host_path not exists or empty"
      exit
  fi
  if [ ! -e $rbd_image ]; then
    mkdir -p $rbd_image
  fi
  if [ ! -e $images ]; then
    mkdir -p $images
  fi

  if [ ! -s $mon_host ]; then
    echo "$func: config/mon_host not exists or empty"
    exit
  fi
  if [ ! -e $mds_host ]; then
    echo "$func: config/mds_host not exists"
    exit
  fi

  # only process, if osd_host_path has been updated recently
  if [ -s $osd_host ] && [ $osd_host -nt $osd_host_path ]; then
    return  
  fi  
  echo "$func: prepare client-side environment ..."
  # create file: osd_host and osd_host_mapping
  >$osd_host
  >$osd_host_mapping
  local lines=0
  local lineno=0

  # serialize osd-node hostname checking
  osd_host_path_sort $osd_host_path

  local lastnode=
  while read line
  do
    lineno=$(($lineno + 1))
    if [ "$line"x = ""x ]; then
      continue;
    fi
    local node=`echo $line|awk '{print $1}'`
    if [ "$node"x = ""x ]; then
      echo "$func: osd_host_path : line $lineno: missing parameter <hostname>"
      rm -rf $osd_host $osd_host_mapping
      exit
    fi
    local data_path=`echo $line|awk '{print $2}'`
    if [ "$data_path"x = ""x ]; then
      echo "$func: osd_host_path : line $lineno: missing parameter <osd_data_path>"
      rm -rf $osd_host $osd_host_mapping
      exit
    fi
    lines=$(($lines + 1))
    # if there are several hostnames for the same node
    # we just need the output of `hostname`
    local hostname_alias=

    if [ "$node"  != "$lastnode" ]; then
      if [ $debug ]; then
	  echo "$func: osd-node $node -> verify hostname, set hostname_alias"
      fi
      hostname_alias=`ssh $ssh_option $node "hostname" 2>/dev/null </dev/null`
      if [ "$hostname_alias"x = ""x ]; then
        echo "$func: osd_host_path: line $lineno: $node: failed to get alias for remote hostname"
	rm -rf $osd_host $osd_host_mapping
	exit
      fi
      echo "$node $hostname_alias" >>$osd_host_mapping
      echo $node >> $osd_host
      # check ceph env on remote osd
      check_ceph_env $node $data_path
      lastnode=$node
    fi
  done < $osd_host_path

  if [ $lines = 0 ]; then
    echo "$func: invalid client setup"
    echo "\tplease create valid configuration lines: <osd-node> <osd_data_path>"
    exit
  fi
}

function osd_host_path_sort()
{
    local osd_host_path=$1
    local t_host_path=/tmp/tmp_osd_host_path.$$$$

    if [ "$1"x = ""x ];then
	echo "$func: missing parameter <osd_host_path>"
	exit
    fi

    cat $osd_host_path | sort -t$'\t' -k 1.1,1 -k 2.24,2.26nr > $t_host_path
    cp $t_host_path $osd_host_path
    rm $t_host_path
}
 

function admin_parse_osd()
{
  local func="admin_parse_osd"
  if [ -s $osd_host ]; then
      return  
  fi
  # create file: osd_host
  >$osd_host
  local lines=0
  local lineno=0
  while read line
  do
    lineno=$(($lineno + 1))
    if [ "$line"x = ""x ]; then
	continue;
    fi
    local node=`echo $line|awk '{print $1}'`
    if [ "$node"x = ""x ]; then
	echo "$func: osd_host_path : line $lineno: osd_host not input"
	exit
    fi
    local data_path=`echo $line|awk '{print $2}'`
    if [ "$data_path"x = ""x ]; then
	echo "$func: osd_host_path : line $lineno: osd_data not input"
	exit
    fi
    lines=$(($lines + 1))
    echo $node >> $osd_host
  done < $osd_host_path
}

# for osd node
function get_omap_list()
{
  if [ $debug ]; then
      echo "get_omap_list: ceph-kvstore-tool $kvdb_type $omap_path list"
  fi	
  ceph-kvstore-tool $kvdb_type $omap_path list > $omap_list
}

function convert_underline()
{
  if [ "$1"x = ""x ]; then
      return
  fi

  echo $1|sed -e 's/_/\\u/gp'|head -n 1
}

function dump_backslash()
{
  echo $*|sed -e 's/\\/\\\\/gp'|head -n 1
}

function dump_dump_backslash()
{
  echo $*|sed -e 's/\\/\\\\\\\\/gp'|head -n 1
}

function char_convert()
{
  if [ "$1"x = ""x ]; then
      return
  fi

  echo $1|sed -e 's/_/\\u/gp' -e 's/\./%e/gp' -e 's/%/%p/gp'|head -n 1
}

function check_osd_process()
{
  local func="check_osd_process"
  local host=$1
  if [ "$1"x = ""x ]; then
      exit
  fi
  local cmds="ps aux|grep ceph-osd|grep -v grep"
  local ret=/tmp/ret.$$$$
  ssh $ssh_option $host $cmds |tee $ret
  if [ -s $ret ]; then
    echo "$func: [$host] ceph-osd process are still active!"
    echo "$func: [$host] we will not proceed to keep intagrity"
    exit
  fi
  rm -f $ret 
}

function get_map_header_prefix()
{
  echo "_HOBJTOSEQ_"
}

function get_map_header_key()
{
  local func="get_map_header_key"
  if [ "$1"x = ""x ]; then
    echo $func': missing parameter <key>'
    exit 
  fi 
  local keyword=$1
  local res=`cat $omap_list| grep $keyword`
  if [ "$res"x = ""x ]; then
      if [ $debug ]; then
	  echo "$func: ceph-kvstore-tool key = $keyword does not exist"
      fi
    exit
  fi
  echo $res|awk -F ":" '{print $2}'
}

function get_header_seq() 
{
  #use ceph-kvstore-tool to extract seq-position
  local func="get_header_seq"
  if [ "$1"x == ""x ]; then
      echo "$func: ceph-kvstore-tool missing parameter <prefix>"
      exit;
  elif [ "$2"x == ""x ]; then
      echo "$func: ceph-kvstore-tool missing parameter <key>"
      exit;
  fi
  local prefix=$1;
  local key=$2;
  local res=/tmp/header_seq.$$$$
  local hexseq
  local seq
  
  # ceph-kvstore-tool dumps values in hex (big-endian format)
  # ($prefix, $key)
  # (_HOBJTOSEQ_, ...head.0.00000011)
  # 00000000  02 01 81 00 00 00 87 e4  12 00 00 00 00 00 00 00
  # relevant seq is coded in uint64: 8 bytes (big-endian):
  # -> 00 00 00 00 00 87 E4 12
  # => 12 e4 87 00 00 00 00 00 
  # use xxd to process the hex dump
  # finally transform the hex output to the needed integer
  # header_seq = echo $((16#000000000012e487)) -> 1238151
  ceph-kvstore-tool $kvdb_type $omap_path get $prefix $key out $res 2>/dev/null 1>/dev/null
  if [ $? != 0 ]; then
      #echo "$func: <$prefix , $key> not exists" ;
      exit;
  fi
  #seq=`cat $res |head -n 2|tail -n 1| \
  #awk '
  #BEGIN {
  #  FS="00000000";
  #  seq="";
  #  i=7;
  #} {
  #  split($2, arr, " "); 
  #  # header_seq uint64 : 8 bytes
  #  for (x=7; x>=0; --x) {
  #    seq=seq""arr[i+x];
  #  }
  #}
  #END {
  # print seq
  #}'`
  # process dump: offset 6, switch next 8 octets to little endian 
  hexseq=`xxd -c 16 -seek 6 -len 8 -e $res | \
       awk 'BEGIN { -F ":" } { print $2; }'`
  seq=`printf "%d" 0x$hexseq`
  if [ "$seq"x = ""x ]; then
      #echo "$func: get <$prefix , $key> failed"
      exit;
  fi
  rm -f $res
  echo $seq
}

# get header info key/value
function get_header_kv()
{
  local func="get_header_kv"
  local prefix=$1
  local key=$2
  local type=$3
  local seek=$4
  local len=$5
  local res=/tmp/kv.$$$$
  local hexvalue
  local value
  
  if [ -z $prefix ]; then
      if [ $debug ]; then
	  echo "$func: ceph-kvstore-tool needs a valid object prefix"
      fi
      exit
  elif [ -z $key ]; then
      if [ $debug ]; then
	  echo "$func: ceph-kvstore-tool needs a valid key "
      fi
      exit
  elif [ "$type"x != "int"x ] && [ "$type"x != "string"x ]; then
      if [ $debug ]; then
	  echo "$func: ceph-kvstore-tool need a valid input type (string|int)"
      fi
      exit
  fi

  # values are dumped in hex (big-endian format)
  #ceph-kvstore-tool $kvdb_type $omap_path get $prefix $key 2>/dev/null 1>$res
  ceph-kvstore-tool $kvdb_type $omap_path get $prefix $key out $res 2>/dev/null 1>/dev/null
  if [ $? != 0 ]; then
      if [ $debug ]; then
	  echo "$func: error -> ceph-kvstore-tool $kvdb_type $omap_path get $prefix $key"
      fi
      exit
  fi


  if [ "$type"x = "string"x ]; then
    # process dump: offset 4, switch next 24 octets
    test -z $seek && seek=4;
    test -z $len && len=24;
    value=`xxd -seek $seek -len $len -p $res | xxd -r -p`
  elif [ "$type"x = "int"x ]; then
   test -z $seek && seek=0;
   test -z $len && len=8;
   hexvalue=`xxd -seek $seek -len $len -e -p $res`
   value=`printf "%d" 0x$hexvalue`
  fi
  #if [ $debug ]; then
  #    echo "\n[debug] $func: key: $prefix -> value: $value>"
  #fi
  rm -f $res
  echo $value
  #echo $__result
}
